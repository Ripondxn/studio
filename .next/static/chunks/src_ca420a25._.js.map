{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/dialog.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,SAAS,6KAAoB;AAEnC,MAAM,gBAAgB,gLAAuB;AAE7C,MAAM,eAAe,+KAAsB;AAE3C,MAAM,cAAc,8KAAqB;AAEzC,MAAM,8BAAgB,2KAAgB,CAGpC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,gLAAuB;QACtB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,0JACA;QAED,GAAG,KAAK;;;;;;;KAVP;AAaN,cAAc,WAAW,GAAG,gLAAuB,CAAC,WAAW;AAE/D,MAAM,8BAAgB,2KAAgB,OAGpC,QAAoC;QAAnC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO;yBAClC,6LAAC;;0BACC,6LAAC;;;;;0BACD,6LAAC,gLAAuB;gBACtB,KAAK;gBACL,WAAW,IAAA,4HAAE,EACX,+fACA;gBAED,GAAG,KAAK;;oBAER;kCACD,6LAAC,8KAAqB;wBAAC,WAAU;;0CAC/B,6LAAC,oMAAC;gCAAC,WAAU;;;;;;0CACb,6LAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;;;AAKlC,cAAc,WAAW,GAAG,gLAAuB,CAAC,WAAW;AAE/D,MAAM,eAAe;QAAC,EACpB,SAAS,EACT,GAAG,OACkC;yBACrC,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,sDACA;QAED,GAAG,KAAK;;;;;;;MATP;AAYN,aAAa,WAAW,GAAG;AAE3B,MAAM,eAAe;QAAC,EACpB,SAAS,EACT,GAAG,OACkC;yBACrC,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,iEACA;QAED,GAAG,KAAK;;;;;;;MATP;AAYN,aAAa,WAAW,GAAG;AAE3B,MAAM,4BAAc,2KAAgB,OAGlC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,8KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,qDACA;QAED,GAAG,KAAK;;;;;;;;AAGb,YAAY,WAAW,GAAG,8KAAqB,CAAC,WAAW;AAE3D,MAAM,kCAAoB,2KAAgB,OAGxC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,oLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;;;AAGb,kBAAkB,WAAW,GAAG,oLAA2B,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 181, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,2KAAgB,MAC5B,QAAgC;QAA/B,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAO;IAC5B,qBACE,6LAAC;QACC,MAAM;QACN,WAAW,IAAA,4HAAE,EACX,kYACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,MAAM,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 217, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,gBAAgB,IAAA,0KAAG,EACvB;AAGF,MAAM,sBAAQ,2KAAgB,MAI5B,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,4KAAmB;QAClB,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,iBAAiB;QAC9B,GAAG,KAAK;;;;;;;;AAGb,MAAM,WAAW,GAAG,4KAAmB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 258, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/schema.ts"],"sourcesContent":["\n\nimport { z } from 'zod';\n\nexport const storeSchema = z.object({\n  id: z.string(),\n  name: z.string().min(1, 'Store name is required.'),\n  location: z.string().optional(),\n});\n\nexport const stockItemSchema = z.object({\n  id: z.string(),\n  storeId: z.string(),\n  productId: z.string(),\n  quantity: z.number().min(0),\n  // These are added dynamically\n  itemName: z.string().optional(),\n  itemCode: z.string().optional(),\n});\n\nexport const stockTransactionSchema = z.object({\n    id: z.string(),\n    date: z.string(),\n    storeId: z.string(),\n    storeName: z.string(),\n    productId: z.string(),\n    productName: z.string(),\n    quantity: z.number(),\n    type: z.enum(['IN', 'OUT']),\n    notes: z.string().optional(),\n    jobId: z.string().optional(),\n});\n\n\nexport type Store = z.infer<typeof storeSchema>;\nexport type StockItem = z.infer<typeof stockItemSchema>;\nexport type StockTransaction = z.infer<typeof stockTransactionSchema>;\nexport type Product = z.infer<typeof productSchema>;\n\nconst productSchema = z.object({\n  id: z.string(),\n  itemCode: z.string().min(1, 'Item code is required.'),\n  itemName: z.string().min(1, 'Item name is required.'),\n  itemType: z.enum(['Product', 'Service']),\n  salePrice: z.number().min(0, 'Sale price must be a positive number.'),\n  costPrice: z.number().min(0, 'Cost price must be a positive number.'),\n});\n"],"names":[],"mappings":";;;;;;;;AAEA;;AAEO,MAAM,cAAc,0KAAC,CAAC,MAAM,CAAC;IAClC,IAAI,0KAAC,CAAC,MAAM;IACZ,MAAM,0KAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IACxB,UAAU,0KAAC,CAAC,MAAM,GAAG,QAAQ;AAC/B;AAEO,MAAM,kBAAkB,0KAAC,CAAC,MAAM,CAAC;IACtC,IAAI,0KAAC,CAAC,MAAM;IACZ,SAAS,0KAAC,CAAC,MAAM;IACjB,WAAW,0KAAC,CAAC,MAAM;IACnB,UAAU,0KAAC,CAAC,MAAM,GAAG,GAAG,CAAC;IACzB,8BAA8B;IAC9B,UAAU,0KAAC,CAAC,MAAM,GAAG,QAAQ;IAC7B,UAAU,0KAAC,CAAC,MAAM,GAAG,QAAQ;AAC/B;AAEO,MAAM,yBAAyB,0KAAC,CAAC,MAAM,CAAC;IAC3C,IAAI,0KAAC,CAAC,MAAM;IACZ,MAAM,0KAAC,CAAC,MAAM;IACd,SAAS,0KAAC,CAAC,MAAM;IACjB,WAAW,0KAAC,CAAC,MAAM;IACnB,WAAW,0KAAC,CAAC,MAAM;IACnB,aAAa,0KAAC,CAAC,MAAM;IACrB,UAAU,0KAAC,CAAC,MAAM;IAClB,MAAM,0KAAC,CAAC,IAAI,CAAC;QAAC;QAAM;KAAM;IAC1B,OAAO,0KAAC,CAAC,MAAM,GAAG,QAAQ;IAC1B,OAAO,0KAAC,CAAC,MAAM,GAAG,QAAQ;AAC9B;AAQA,MAAM,gBAAgB,0KAAC,CAAC,MAAM,CAAC;IAC7B,IAAI,0KAAC,CAAC,MAAM;IACZ,UAAU,0KAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IAC5B,UAAU,0KAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IAC5B,UAAU,0KAAC,CAAC,IAAI,CAAC;QAAC;QAAW;KAAU;IACvC,WAAW,0KAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IAC7B,WAAW,0KAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;AAC/B","debugId":null}},
    {"offset": {"line": 315, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { storeSchema, stockItemSchema, type Store, type StockItem, type StockTransaction } from './schema';\nimport { type Product } from '@/app/products/schema';\n\nconst storesFilePath = path.join(process.cwd(), 'src/app/stores/stores-data.json');\nconst stockFilePath = path.join(process.cwd(), 'src/app/stores/stock-data.json');\nconst stockTransactionsFilePath = path.join(process.cwd(), 'src/app/stores/stock-transactions.json');\nconst productsFilePath = path.join(process.cwd(), 'src/app/products/products-data.json');\n\n\nasync function readData<T>(filePath: string, defaultValue: T[] = []): Promise<T[]> {\n    try {\n        await fs.access(filePath);\n        const data = await fs.readFile(filePath, 'utf-8');\n        return JSON.parse(data);\n    } catch (error) {\n        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n            await fs.writeFile(filePath, JSON.stringify(defaultValue, null, 2), 'utf-8');\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n\nasync function writeData(filePath: string, data: any) {\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n}\n\n\n// Store Actions\nexport async function getStores(): Promise<Store[]> {\n    return await readData<Store>(storesFilePath);\n}\n\nexport async function saveStore(data: Omit<Store, 'id'> & { id?: string }) {\n    const validation = storeSchema.omit({id: true}).safeParse(data);\n    if (!validation.success) return { success: false, error: 'Invalid data format.' };\n\n    const stores = await getStores();\n    if (data.id) { // Update\n        const index = stores.findIndex(s => s.id === data.id);\n        if (index === -1) return { success: false, error: 'Store not found.' };\n        stores[index] = { ...stores[index], ...validation.data };\n    } else { // Create\n        const newStore: Store = { ...validation.data, id: `STORE-${Date.now()}` };\n        stores.push(newStore);\n    }\n\n    await writeData(storesFilePath, stores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\nexport async function deleteStore(storeId: string) {\n    const stores = await getStores();\n    const updatedStores = stores.filter(s => s.id !== storeId);\n    if (stores.length === updatedStores.length) {\n        return { success: false, error: 'Store not found.' };\n    }\n    await writeData(storesFilePath, updatedStores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\n// Stock Actions\nexport async function getStockForStore(storeId: string): Promise<StockItem[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const productMap = new Map(products.map(p => [p.id, p]));\n\n    return allStock\n        .filter(item => item.storeId === storeId)\n        .map(item => ({\n            ...item,\n            itemName: productMap.get(item.productId)?.itemName || 'Unknown Item',\n            itemCode: productMap.get(item.productId)?.itemCode || 'Unknown',\n        }));\n}\n\nexport async function getAggregatedStock(): Promise<any[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const stores = await getStores();\n\n    const productMap = new Map(products.map(p => [p.id, p]));\n    const storeMap = new Map(stores.map(s => [s.id, s]));\n    \n    const aggregatedStock = new Map<string, any>();\n\n    for(const item of allStock) {\n        if (!productMap.has(item.productId)) continue;\n\n        if (!aggregatedStock.has(item.productId)) {\n            const product = productMap.get(item.productId)!;\n            aggregatedStock.set(item.productId, {\n                productId: item.productId,\n                itemName: product.itemName,\n                itemCode: product.itemCode,\n                totalQuantity: 0,\n                locations: [],\n            });\n        }\n\n        const aggItem = aggregatedStock.get(item.productId)!;\n        aggItem.totalQuantity += item.quantity;\n        aggItem.locations.push({\n            storeName: storeMap.get(item.storeId)?.name || 'Unknown Store',\n            quantity: item.quantity,\n        });\n    }\n\n    return Array.from(aggregatedStock.values());\n}\n\n\nexport async function getProductsForSelect(): Promise<{value: string, label: string}[]> {\n    const products = await readData<Product>(productsFilePath);\n    return products.map(p => ({ value: p.id, label: `${p.itemName} (${p.itemCode})`}));\n}\n\n\n// Transaction Actions\nconst transactionSchema = z.object({\n    storeId: z.string(),\n    productId: z.string(),\n    quantity: z.coerce.number().min(1, 'Quantity must be at least 1.'),\n    transactionType: z.enum(['IN', 'OUT']),\n    notes: z.string().optional(),\n    jobId: z.string().optional(),\n});\n\n\nexport async function recordStockTransaction(data: z.infer<typeof transactionSchema>) {\n    const validation = transactionSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: 'Invalid data format.' };\n    }\n\n    const { storeId, productId, quantity, transactionType, notes, jobId } = validation.data;\n    \n    // 1. Update Stock Level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === storeId && item.productId === productId);\n\n    if (transactionType === 'IN') {\n        if (stockItemIndex > -1) {\n            allStock[stockItemIndex].quantity += quantity;\n        } else {\n            allStock.push({\n                id: `STOCK-${Date.now()}`,\n                storeId,\n                productId,\n                quantity,\n            });\n        }\n    } else { // OUT\n        if (stockItemIndex === -1 || allStock[stockItemIndex].quantity < quantity) {\n            return { success: false, error: 'Insufficient stock for this transaction.' };\n        }\n        allStock[stockItemIndex].quantity -= quantity;\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // 2. Record Transaction\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === productId);\n    const store = (await getStores()).find(s => s.id === storeId);\n    \n    const newTransaction: StockTransaction = {\n        id: `TXN-${Date.now()}`,\n        date: new Date().toISOString(),\n        storeId,\n        storeName: store?.name || 'Unknown Store',\n        productId,\n        productName: product?.itemName || 'Unknown Item',\n        quantity,\n        type: transactionType,\n        notes,\n        jobId\n    };\n    allTransactions.push(newTransaction);\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    // 3. Financial Impact\n    const cost = product?.costPrice || 0;\n    const value = quantity * cost;\n    \n    // This is a simplified financial integration.\n    // A more robust system would create journal entries.\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140'); // Maintenance & Repairs\n\n    if (transactionType === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) + value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) - value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance = (allAccounts[expenseAccountIndex].balance || 0) + value;\n        }\n    }\n    \n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n\n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n\nexport async function getTransactionHistory(): Promise<StockTransaction[]> {\n    return await readData<StockTransaction>(stockTransactionsFilePath);\n}\n\nconst transferSchema = z.object({\n  fromStoreId: z.string().min(1, 'Source store is required'),\n  toStoreId: z.string().min(1, 'Destination store is required'),\n  productId: z.string().min(1, 'Product is required'),\n  quantity: z.coerce.number().min(1, 'Quantity must be at least 1'),\n  notes: z.string().optional(),\n}).refine(data => data.fromStoreId !== data.toStoreId, {\n    message: \"Source and destination stores cannot be the same.\",\n    path: ['toStoreId'],\n});\n\nexport async function transferStock(data: z.infer<typeof transferSchema>) {\n    const validation = transferSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: validation.error.errors[0].message };\n    }\n\n    const { fromStoreId, toStoreId, productId, quantity, notes } = validation.data;\n    \n    const allStock = await readData<StockItem>(stockFilePath);\n    const sourceStockIndex = allStock.findIndex(item => item.storeId === fromStoreId && item.productId === productId);\n    \n    // Check for sufficient stock\n    if (sourceStockIndex === -1 || allStock[sourceStockIndex].quantity < quantity) {\n        return { success: false, error: 'Insufficient stock in the source store.' };\n    }\n\n    // Decrement from source\n    allStock[sourceStockIndex].quantity -= quantity;\n\n    // Increment in destination\n    const destinationStockIndex = allStock.findIndex(item => item.storeId === toStoreId && item.productId === productId);\n    if (destinationStockIndex > -1) {\n        allStock[destinationStockIndex].quantity += quantity;\n    } else {\n        allStock.push({ id: `STOCK-${Date.now()}`, storeId: toStoreId, productId, quantity });\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // Record transactions\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const stores = await getStores();\n    const products = await readData<Product>(productsFilePath);\n    const fromStoreName = stores.find(s => s.id === fromStoreId)?.name || 'Unknown';\n    const toStoreName = stores.find(s => s.id === toStoreId)?.name || 'Unknown';\n    const productName = products.find(p => p.id === productId)?.itemName || 'Unknown';\n    const transferRef = `TRN-${Date.now()}`;\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-OUT`,\n        date: new Date().toISOString(),\n        storeId: fromStoreId,\n        storeName: fromStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'OUT',\n        notes: `Transfer to ${toStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-IN`,\n        date: new Date().toISOString(),\n        storeId: toStoreId,\n        storeName: toStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'IN',\n        notes: `Transfer from ${fromStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\nexport async function deleteStockTransaction(transactionId: string) {\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const transactionToDelete = allTransactions.find(t => t.id === transactionId);\n\n    if (!transactionToDelete) {\n        return { success: false, error: \"Transaction not found.\" };\n    }\n    \n    // Reverse stock level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === transactionToDelete.storeId && item.productId === transactionToDelete.productId);\n\n    if (stockItemIndex > -1) {\n        if (transactionToDelete.type === 'IN') {\n            allStock[stockItemIndex].quantity -= transactionToDelete.quantity;\n        } else { // OUT\n            allStock[stockItemIndex].quantity += transactionToDelete.quantity;\n        }\n        await writeData(stockFilePath, allStock);\n    }\n\n    // Reverse financial impact\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === transactionToDelete.productId);\n    const cost = product?.costPrice || 0;\n    const value = transactionToDelete.quantity * cost;\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140');\n\n    if (transactionToDelete.type === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance -= value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance += value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance -= value;\n        }\n    }\n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n    // Remove transaction log\n    const updatedTransactions = allTransactions.filter(t => t.id !== transactionId);\n    await writeData(stockTransactionsFilePath, updatedTransactions);\n    \n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IAwCsB,YAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 330, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/add-store-dialog.tsx"],"sourcesContent":["\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n  DialogClose,\n} from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { useToast } from '@/hooks/use-toast';\nimport { Loader2 } from 'lucide-react';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { storeSchema, type Store } from './schema';\nimport { saveStore } from './actions';\n\n\ntype StoreFormData = Omit<Store, 'id'> & { id?: string };\n\ninterface AddStoreDialogProps {\n  isOpen: boolean;\n  setIsOpen: (open: boolean) => void;\n  store?: Store;\n  onSuccess: () => void;\n}\n\nexport function AddStoreDialog({ isOpen, setIsOpen, store, onSuccess }: AddStoreDialogProps) {\n  const [isSaving, setIsSaving] = useState(false);\n  const { toast } = useToast();\n\n  const {\n    register,\n    handleSubmit,\n    reset,\n    formState: { errors },\n  } = useForm<StoreFormData>({\n    resolver: zodResolver(storeSchema.omit({id:true})),\n  });\n\n  useEffect(() => {\n    if (isOpen) {\n        reset(store || { name: '', location: '' });\n    }\n  }, [isOpen, store, reset]);\n\n  const onSubmit = async (data: StoreFormData) => {\n    setIsSaving(true);\n    const result = await saveStore({ ...data, id: store?.id });\n\n    if (result.success) {\n      toast({\n        title: store ? 'Store Updated' : 'Store Added',\n        description: `Successfully ${store ? 'updated' : 'added'} store.`,\n      });\n      onSuccess();\n      setIsOpen(false);\n    } else {\n      toast({\n        variant: 'destructive',\n        title: 'Error',\n        description: result.error,\n      });\n    }\n    setIsSaving(false);\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={setIsOpen}>\n      <DialogContent>\n        <form onSubmit={handleSubmit(onSubmit)}>\n            <DialogHeader>\n            <DialogTitle>{store ? 'Edit Store' : 'Add New Store'}</DialogTitle>\n            <DialogDescription>\n                Fill in the details for the new store or vault location.\n            </DialogDescription>\n            </DialogHeader>\n            <div className=\"grid gap-4 py-4\">\n                <div className=\"space-y-2\">\n                    <Label htmlFor=\"name\">Store Name</Label>\n                    <Input id=\"name\" {...register('name')} placeholder=\"e.g., Main Warehouse, Site Office A\" />\n                    {errors.name && <p className=\"text-destructive text-xs mt-1\">{errors.name.message}</p>}\n                </div>\n                 <div className=\"space-y-2\">\n                    <Label htmlFor=\"location\">Location</Label>\n                    <Input id=\"location\" {...register('location')} placeholder=\"e.g., Dubai, UAE or Project Site B\" />\n                </div>\n            </div>\n            <DialogFooter>\n                <DialogClose asChild>\n                    <Button type=\"button\" variant=\"outline\">Cancel</Button>\n                </DialogClose>\n                <Button type=\"submit\" disabled={isSaving}>\n                    {isSaving && <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />}\n                    {store ? 'Save Changes' : 'Add Store'}\n                </Button>\n            </DialogFooter>\n        </form>\n      </DialogContent>\n    </Dialog>\n  );\n}\n"],"names":[],"mappings":";;;;;AAGA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AApBA;;;;;;;;;;;;AAgCO,SAAS,eAAe,KAA4D;QAA5D,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,SAAS,EAAuB,GAA5D;;IAC7B,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,yKAAQ,EAAC;IACzC,MAAM,EAAE,KAAK,EAAE,GAAG,IAAA,2IAAQ;IAE1B,MAAM,EACJ,QAAQ,EACR,YAAY,EACZ,KAAK,EACL,WAAW,EAAE,MAAM,EAAE,EACtB,GAAG,IAAA,4KAAO,EAAgB;QACzB,UAAU,IAAA,gLAAW,EAAC,gJAAW,CAAC,IAAI,CAAC;YAAC,IAAG;QAAI;IACjD;IAEA,IAAA,0KAAS;oCAAC;YACR,IAAI,QAAQ;gBACR,MAAM,SAAS;oBAAE,MAAM;oBAAI,UAAU;gBAAG;YAC5C;QACF;mCAAG;QAAC;QAAQ;QAAO;KAAM;IAEzB,MAAM,WAAW,OAAO;QACtB,YAAY;QACZ,MAAM,SAAS,MAAM,IAAA,4KAAS,EAAC;YAAE,GAAG,IAAI;YAAE,EAAE,EAAE,kBAAA,4BAAA,MAAO,EAAE;QAAC;QAExD,IAAI,OAAO,OAAO,EAAE;YAClB,MAAM;gBACJ,OAAO,QAAQ,kBAAkB;gBACjC,aAAa,AAAC,gBAA2C,OAA5B,QAAQ,YAAY,SAAQ;YAC3D;YACA;YACA,UAAU;QACZ,OAAO;YACL,MAAM;gBACJ,SAAS;gBACT,OAAO;gBACP,aAAa,OAAO,KAAK;YAC3B;QACF;QACA,YAAY;IACd;IAEA,qBACE,6LAAC,+IAAM;QAAC,MAAM;QAAQ,cAAc;kBAClC,cAAA,6LAAC,sJAAa;sBACZ,cAAA,6LAAC;gBAAK,UAAU,aAAa;;kCACzB,6LAAC,qJAAY;;0CACb,6LAAC,oJAAW;0CAAE,QAAQ,eAAe;;;;;;0CACrC,6LAAC,0JAAiB;0CAAC;;;;;;;;;;;;kCAInB,6LAAC;wBAAI,WAAU;;0CACX,6LAAC;gCAAI,WAAU;;kDACX,6LAAC,6IAAK;wCAAC,SAAQ;kDAAO;;;;;;kDACtB,6LAAC,6IAAK;wCAAC,IAAG;wCAAQ,GAAG,SAAS,OAAO;wCAAE,aAAY;;;;;;oCAClD,OAAO,IAAI,kBAAI,6LAAC;wCAAE,WAAU;kDAAiC,OAAO,IAAI,CAAC,OAAO;;;;;;;;;;;;0CAEpF,6LAAC;gCAAI,WAAU;;kDACZ,6LAAC,6IAAK;wCAAC,SAAQ;kDAAW;;;;;;kDAC1B,6LAAC,6IAAK;wCAAC,IAAG;wCAAY,GAAG,SAAS,WAAW;wCAAE,aAAY;;;;;;;;;;;;;;;;;;kCAGnE,6LAAC,qJAAY;;0CACT,6LAAC,oJAAW;gCAAC,OAAO;0CAChB,cAAA,6LAAC,+IAAM;oCAAC,MAAK;oCAAS,SAAQ;8CAAU;;;;;;;;;;;0CAE5C,6LAAC,+IAAM;gCAAC,MAAK;gCAAS,UAAU;;oCAC3B,0BAAY,6LAAC,+NAAO;wCAAC,WAAU;;;;;;oCAC/B,QAAQ,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAO9C;GA1EgB;;QAEI,2IAAQ;QAOtB,4KAAO;;;KATG","debugId":null}},
    {"offset": {"line": 579, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { storeSchema, stockItemSchema, type Store, type StockItem, type StockTransaction } from './schema';\nimport { type Product } from '@/app/products/schema';\n\nconst storesFilePath = path.join(process.cwd(), 'src/app/stores/stores-data.json');\nconst stockFilePath = path.join(process.cwd(), 'src/app/stores/stock-data.json');\nconst stockTransactionsFilePath = path.join(process.cwd(), 'src/app/stores/stock-transactions.json');\nconst productsFilePath = path.join(process.cwd(), 'src/app/products/products-data.json');\n\n\nasync function readData<T>(filePath: string, defaultValue: T[] = []): Promise<T[]> {\n    try {\n        await fs.access(filePath);\n        const data = await fs.readFile(filePath, 'utf-8');\n        return JSON.parse(data);\n    } catch (error) {\n        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n            await fs.writeFile(filePath, JSON.stringify(defaultValue, null, 2), 'utf-8');\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n\nasync function writeData(filePath: string, data: any) {\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n}\n\n\n// Store Actions\nexport async function getStores(): Promise<Store[]> {\n    return await readData<Store>(storesFilePath);\n}\n\nexport async function saveStore(data: Omit<Store, 'id'> & { id?: string }) {\n    const validation = storeSchema.omit({id: true}).safeParse(data);\n    if (!validation.success) return { success: false, error: 'Invalid data format.' };\n\n    const stores = await getStores();\n    if (data.id) { // Update\n        const index = stores.findIndex(s => s.id === data.id);\n        if (index === -1) return { success: false, error: 'Store not found.' };\n        stores[index] = { ...stores[index], ...validation.data };\n    } else { // Create\n        const newStore: Store = { ...validation.data, id: `STORE-${Date.now()}` };\n        stores.push(newStore);\n    }\n\n    await writeData(storesFilePath, stores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\nexport async function deleteStore(storeId: string) {\n    const stores = await getStores();\n    const updatedStores = stores.filter(s => s.id !== storeId);\n    if (stores.length === updatedStores.length) {\n        return { success: false, error: 'Store not found.' };\n    }\n    await writeData(storesFilePath, updatedStores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\n// Stock Actions\nexport async function getStockForStore(storeId: string): Promise<StockItem[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const productMap = new Map(products.map(p => [p.id, p]));\n\n    return allStock\n        .filter(item => item.storeId === storeId)\n        .map(item => ({\n            ...item,\n            itemName: productMap.get(item.productId)?.itemName || 'Unknown Item',\n            itemCode: productMap.get(item.productId)?.itemCode || 'Unknown',\n        }));\n}\n\nexport async function getAggregatedStock(): Promise<any[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const stores = await getStores();\n\n    const productMap = new Map(products.map(p => [p.id, p]));\n    const storeMap = new Map(stores.map(s => [s.id, s]));\n    \n    const aggregatedStock = new Map<string, any>();\n\n    for(const item of allStock) {\n        if (!productMap.has(item.productId)) continue;\n\n        if (!aggregatedStock.has(item.productId)) {\n            const product = productMap.get(item.productId)!;\n            aggregatedStock.set(item.productId, {\n                productId: item.productId,\n                itemName: product.itemName,\n                itemCode: product.itemCode,\n                totalQuantity: 0,\n                locations: [],\n            });\n        }\n\n        const aggItem = aggregatedStock.get(item.productId)!;\n        aggItem.totalQuantity += item.quantity;\n        aggItem.locations.push({\n            storeName: storeMap.get(item.storeId)?.name || 'Unknown Store',\n            quantity: item.quantity,\n        });\n    }\n\n    return Array.from(aggregatedStock.values());\n}\n\n\nexport async function getProductsForSelect(): Promise<{value: string, label: string}[]> {\n    const products = await readData<Product>(productsFilePath);\n    return products.map(p => ({ value: p.id, label: `${p.itemName} (${p.itemCode})`}));\n}\n\n\n// Transaction Actions\nconst transactionSchema = z.object({\n    storeId: z.string(),\n    productId: z.string(),\n    quantity: z.coerce.number().min(1, 'Quantity must be at least 1.'),\n    transactionType: z.enum(['IN', 'OUT']),\n    notes: z.string().optional(),\n    jobId: z.string().optional(),\n});\n\n\nexport async function recordStockTransaction(data: z.infer<typeof transactionSchema>) {\n    const validation = transactionSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: 'Invalid data format.' };\n    }\n\n    const { storeId, productId, quantity, transactionType, notes, jobId } = validation.data;\n    \n    // 1. Update Stock Level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === storeId && item.productId === productId);\n\n    if (transactionType === 'IN') {\n        if (stockItemIndex > -1) {\n            allStock[stockItemIndex].quantity += quantity;\n        } else {\n            allStock.push({\n                id: `STOCK-${Date.now()}`,\n                storeId,\n                productId,\n                quantity,\n            });\n        }\n    } else { // OUT\n        if (stockItemIndex === -1 || allStock[stockItemIndex].quantity < quantity) {\n            return { success: false, error: 'Insufficient stock for this transaction.' };\n        }\n        allStock[stockItemIndex].quantity -= quantity;\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // 2. Record Transaction\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === productId);\n    const store = (await getStores()).find(s => s.id === storeId);\n    \n    const newTransaction: StockTransaction = {\n        id: `TXN-${Date.now()}`,\n        date: new Date().toISOString(),\n        storeId,\n        storeName: store?.name || 'Unknown Store',\n        productId,\n        productName: product?.itemName || 'Unknown Item',\n        quantity,\n        type: transactionType,\n        notes,\n        jobId\n    };\n    allTransactions.push(newTransaction);\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    // 3. Financial Impact\n    const cost = product?.costPrice || 0;\n    const value = quantity * cost;\n    \n    // This is a simplified financial integration.\n    // A more robust system would create journal entries.\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140'); // Maintenance & Repairs\n\n    if (transactionType === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) + value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) - value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance = (allAccounts[expenseAccountIndex].balance || 0) + value;\n        }\n    }\n    \n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n\n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n\nexport async function getTransactionHistory(): Promise<StockTransaction[]> {\n    return await readData<StockTransaction>(stockTransactionsFilePath);\n}\n\nconst transferSchema = z.object({\n  fromStoreId: z.string().min(1, 'Source store is required'),\n  toStoreId: z.string().min(1, 'Destination store is required'),\n  productId: z.string().min(1, 'Product is required'),\n  quantity: z.coerce.number().min(1, 'Quantity must be at least 1'),\n  notes: z.string().optional(),\n}).refine(data => data.fromStoreId !== data.toStoreId, {\n    message: \"Source and destination stores cannot be the same.\",\n    path: ['toStoreId'],\n});\n\nexport async function transferStock(data: z.infer<typeof transferSchema>) {\n    const validation = transferSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: validation.error.errors[0].message };\n    }\n\n    const { fromStoreId, toStoreId, productId, quantity, notes } = validation.data;\n    \n    const allStock = await readData<StockItem>(stockFilePath);\n    const sourceStockIndex = allStock.findIndex(item => item.storeId === fromStoreId && item.productId === productId);\n    \n    // Check for sufficient stock\n    if (sourceStockIndex === -1 || allStock[sourceStockIndex].quantity < quantity) {\n        return { success: false, error: 'Insufficient stock in the source store.' };\n    }\n\n    // Decrement from source\n    allStock[sourceStockIndex].quantity -= quantity;\n\n    // Increment in destination\n    const destinationStockIndex = allStock.findIndex(item => item.storeId === toStoreId && item.productId === productId);\n    if (destinationStockIndex > -1) {\n        allStock[destinationStockIndex].quantity += quantity;\n    } else {\n        allStock.push({ id: `STOCK-${Date.now()}`, storeId: toStoreId, productId, quantity });\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // Record transactions\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const stores = await getStores();\n    const products = await readData<Product>(productsFilePath);\n    const fromStoreName = stores.find(s => s.id === fromStoreId)?.name || 'Unknown';\n    const toStoreName = stores.find(s => s.id === toStoreId)?.name || 'Unknown';\n    const productName = products.find(p => p.id === productId)?.itemName || 'Unknown';\n    const transferRef = `TRN-${Date.now()}`;\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-OUT`,\n        date: new Date().toISOString(),\n        storeId: fromStoreId,\n        storeName: fromStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'OUT',\n        notes: `Transfer to ${toStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-IN`,\n        date: new Date().toISOString(),\n        storeId: toStoreId,\n        storeName: toStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'IN',\n        notes: `Transfer from ${fromStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\nexport async function deleteStockTransaction(transactionId: string) {\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const transactionToDelete = allTransactions.find(t => t.id === transactionId);\n\n    if (!transactionToDelete) {\n        return { success: false, error: \"Transaction not found.\" };\n    }\n    \n    // Reverse stock level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === transactionToDelete.storeId && item.productId === transactionToDelete.productId);\n\n    if (stockItemIndex > -1) {\n        if (transactionToDelete.type === 'IN') {\n            allStock[stockItemIndex].quantity -= transactionToDelete.quantity;\n        } else { // OUT\n            allStock[stockItemIndex].quantity += transactionToDelete.quantity;\n        }\n        await writeData(stockFilePath, allStock);\n    }\n\n    // Reverse financial impact\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === transactionToDelete.productId);\n    const cost = product?.costPrice || 0;\n    const value = transactionToDelete.quantity * cost;\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140');\n\n    if (transactionToDelete.type === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance -= value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance += value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance -= value;\n        }\n    }\n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n    // Remove transaction log\n    const updatedTransactions = allTransactions.filter(t => t.id !== transactionId);\n    await writeData(stockTransactionsFilePath, updatedTransactions);\n    \n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IAoCsB,YAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 594, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/alert-dialog.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPortal>\n    <AlertDialogOverlay />\n    <AlertDialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    />\n  </AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n\nconst AlertDialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold\", className)}\n    {...props}\n  />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nAlertDialogDescription.displayName =\n  AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Action\n    ref={ref}\n    className={cn(buttonVariants(), className)}\n    {...props}\n  />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Cancel\n    ref={ref}\n    className={cn(\n      buttonVariants({ variant: \"outline\" }),\n      \"mt-2 sm:mt-0\",\n      className\n    )}\n    {...props}\n  />\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AAEA;AACA;AANA;;;;;;AAQA,MAAM,cAAc,sLAAyB;AAE7C,MAAM,qBAAqB,yLAA4B;AAEvD,MAAM,oBAAoB,wLAA2B;AAErD,MAAM,mCAAqB,2KAAgB,CAGzC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,yLAA4B;QAC3B,WAAW,IAAA,4HAAE,EACX,2JACA;QAED,GAAG,KAAK;QACT,KAAK;;;;;;;KAVH;AAaN,mBAAmB,WAAW,GAAG,yLAA4B,CAAC,WAAW;AAEzE,MAAM,mCAAqB,2KAAgB,OAGzC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;;0BACC,6LAAC;;;;;0BACD,6LAAC,yLAA4B;gBAC3B,KAAK;gBACL,WAAW,IAAA,4HAAE,EACX,+fACA;gBAED,GAAG,KAAK;;;;;;;;;;;;;;AAIf,mBAAmB,WAAW,GAAG,yLAA4B,CAAC,WAAW;AAEzE,MAAM,oBAAoB;QAAC,EACzB,SAAS,EACT,GAAG,OACkC;yBACrC,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,oDACA;QAED,GAAG,KAAK;;;;;;;MATP;AAYN,kBAAkB,WAAW,GAAG;AAEhC,MAAM,oBAAoB;QAAC,EACzB,SAAS,EACT,GAAG,OACkC;yBACrC,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,iEACA;QAED,GAAG,KAAK;;;;;;;MATP;AAYN,kBAAkB,WAAW,GAAG;AAEhC,MAAM,iCAAmB,2KAAgB,OAGvC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,uLAA0B;QACzB,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,yBAAyB;QACtC,GAAG,KAAK;;;;;;;;AAGb,iBAAiB,WAAW,GAAG,uLAA0B,CAAC,WAAW;AAErE,MAAM,uCAAyB,2KAAgB,OAG7C,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,6LAAgC;QAC/B,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;;;AAGb,uBAAuB,WAAW,GAChC,6LAAgC,CAAC,WAAW;AAE9C,MAAM,kCAAoB,2KAAgB,OAGxC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,wLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,IAAA,uJAAc,KAAI;QAC/B,GAAG,KAAK;;;;;;;;AAGb,kBAAkB,WAAW,GAAG,wLAA2B,CAAC,WAAW;AAEvE,MAAM,kCAAoB,2KAAgB,QAGxC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,wLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,IAAA,uJAAc,EAAC;YAAE,SAAS;QAAU,IACpC,gBACA;QAED,GAAG,KAAK;;;;;;;;AAGb,kBAAkB,WAAW,GAAG,wLAA2B,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 779, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { storeSchema, stockItemSchema, type Store, type StockItem, type StockTransaction } from './schema';\nimport { type Product } from '@/app/products/schema';\n\nconst storesFilePath = path.join(process.cwd(), 'src/app/stores/stores-data.json');\nconst stockFilePath = path.join(process.cwd(), 'src/app/stores/stock-data.json');\nconst stockTransactionsFilePath = path.join(process.cwd(), 'src/app/stores/stock-transactions.json');\nconst productsFilePath = path.join(process.cwd(), 'src/app/products/products-data.json');\n\n\nasync function readData<T>(filePath: string, defaultValue: T[] = []): Promise<T[]> {\n    try {\n        await fs.access(filePath);\n        const data = await fs.readFile(filePath, 'utf-8');\n        return JSON.parse(data);\n    } catch (error) {\n        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n            await fs.writeFile(filePath, JSON.stringify(defaultValue, null, 2), 'utf-8');\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n\nasync function writeData(filePath: string, data: any) {\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n}\n\n\n// Store Actions\nexport async function getStores(): Promise<Store[]> {\n    return await readData<Store>(storesFilePath);\n}\n\nexport async function saveStore(data: Omit<Store, 'id'> & { id?: string }) {\n    const validation = storeSchema.omit({id: true}).safeParse(data);\n    if (!validation.success) return { success: false, error: 'Invalid data format.' };\n\n    const stores = await getStores();\n    if (data.id) { // Update\n        const index = stores.findIndex(s => s.id === data.id);\n        if (index === -1) return { success: false, error: 'Store not found.' };\n        stores[index] = { ...stores[index], ...validation.data };\n    } else { // Create\n        const newStore: Store = { ...validation.data, id: `STORE-${Date.now()}` };\n        stores.push(newStore);\n    }\n\n    await writeData(storesFilePath, stores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\nexport async function deleteStore(storeId: string) {\n    const stores = await getStores();\n    const updatedStores = stores.filter(s => s.id !== storeId);\n    if (stores.length === updatedStores.length) {\n        return { success: false, error: 'Store not found.' };\n    }\n    await writeData(storesFilePath, updatedStores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\n// Stock Actions\nexport async function getStockForStore(storeId: string): Promise<StockItem[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const productMap = new Map(products.map(p => [p.id, p]));\n\n    return allStock\n        .filter(item => item.storeId === storeId)\n        .map(item => ({\n            ...item,\n            itemName: productMap.get(item.productId)?.itemName || 'Unknown Item',\n            itemCode: productMap.get(item.productId)?.itemCode || 'Unknown',\n        }));\n}\n\nexport async function getAggregatedStock(): Promise<any[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const stores = await getStores();\n\n    const productMap = new Map(products.map(p => [p.id, p]));\n    const storeMap = new Map(stores.map(s => [s.id, s]));\n    \n    const aggregatedStock = new Map<string, any>();\n\n    for(const item of allStock) {\n        if (!productMap.has(item.productId)) continue;\n\n        if (!aggregatedStock.has(item.productId)) {\n            const product = productMap.get(item.productId)!;\n            aggregatedStock.set(item.productId, {\n                productId: item.productId,\n                itemName: product.itemName,\n                itemCode: product.itemCode,\n                totalQuantity: 0,\n                locations: [],\n            });\n        }\n\n        const aggItem = aggregatedStock.get(item.productId)!;\n        aggItem.totalQuantity += item.quantity;\n        aggItem.locations.push({\n            storeName: storeMap.get(item.storeId)?.name || 'Unknown Store',\n            quantity: item.quantity,\n        });\n    }\n\n    return Array.from(aggregatedStock.values());\n}\n\n\nexport async function getProductsForSelect(): Promise<{value: string, label: string}[]> {\n    const products = await readData<Product>(productsFilePath);\n    return products.map(p => ({ value: p.id, label: `${p.itemName} (${p.itemCode})`}));\n}\n\n\n// Transaction Actions\nconst transactionSchema = z.object({\n    storeId: z.string(),\n    productId: z.string(),\n    quantity: z.coerce.number().min(1, 'Quantity must be at least 1.'),\n    transactionType: z.enum(['IN', 'OUT']),\n    notes: z.string().optional(),\n    jobId: z.string().optional(),\n});\n\n\nexport async function recordStockTransaction(data: z.infer<typeof transactionSchema>) {\n    const validation = transactionSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: 'Invalid data format.' };\n    }\n\n    const { storeId, productId, quantity, transactionType, notes, jobId } = validation.data;\n    \n    // 1. Update Stock Level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === storeId && item.productId === productId);\n\n    if (transactionType === 'IN') {\n        if (stockItemIndex > -1) {\n            allStock[stockItemIndex].quantity += quantity;\n        } else {\n            allStock.push({\n                id: `STOCK-${Date.now()}`,\n                storeId,\n                productId,\n                quantity,\n            });\n        }\n    } else { // OUT\n        if (stockItemIndex === -1 || allStock[stockItemIndex].quantity < quantity) {\n            return { success: false, error: 'Insufficient stock for this transaction.' };\n        }\n        allStock[stockItemIndex].quantity -= quantity;\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // 2. Record Transaction\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === productId);\n    const store = (await getStores()).find(s => s.id === storeId);\n    \n    const newTransaction: StockTransaction = {\n        id: `TXN-${Date.now()}`,\n        date: new Date().toISOString(),\n        storeId,\n        storeName: store?.name || 'Unknown Store',\n        productId,\n        productName: product?.itemName || 'Unknown Item',\n        quantity,\n        type: transactionType,\n        notes,\n        jobId\n    };\n    allTransactions.push(newTransaction);\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    // 3. Financial Impact\n    const cost = product?.costPrice || 0;\n    const value = quantity * cost;\n    \n    // This is a simplified financial integration.\n    // A more robust system would create journal entries.\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140'); // Maintenance & Repairs\n\n    if (transactionType === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) + value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) - value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance = (allAccounts[expenseAccountIndex].balance || 0) + value;\n        }\n    }\n    \n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n\n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n\nexport async function getTransactionHistory(): Promise<StockTransaction[]> {\n    return await readData<StockTransaction>(stockTransactionsFilePath);\n}\n\nconst transferSchema = z.object({\n  fromStoreId: z.string().min(1, 'Source store is required'),\n  toStoreId: z.string().min(1, 'Destination store is required'),\n  productId: z.string().min(1, 'Product is required'),\n  quantity: z.coerce.number().min(1, 'Quantity must be at least 1'),\n  notes: z.string().optional(),\n}).refine(data => data.fromStoreId !== data.toStoreId, {\n    message: \"Source and destination stores cannot be the same.\",\n    path: ['toStoreId'],\n});\n\nexport async function transferStock(data: z.infer<typeof transferSchema>) {\n    const validation = transferSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: validation.error.errors[0].message };\n    }\n\n    const { fromStoreId, toStoreId, productId, quantity, notes } = validation.data;\n    \n    const allStock = await readData<StockItem>(stockFilePath);\n    const sourceStockIndex = allStock.findIndex(item => item.storeId === fromStoreId && item.productId === productId);\n    \n    // Check for sufficient stock\n    if (sourceStockIndex === -1 || allStock[sourceStockIndex].quantity < quantity) {\n        return { success: false, error: 'Insufficient stock in the source store.' };\n    }\n\n    // Decrement from source\n    allStock[sourceStockIndex].quantity -= quantity;\n\n    // Increment in destination\n    const destinationStockIndex = allStock.findIndex(item => item.storeId === toStoreId && item.productId === productId);\n    if (destinationStockIndex > -1) {\n        allStock[destinationStockIndex].quantity += quantity;\n    } else {\n        allStock.push({ id: `STOCK-${Date.now()}`, storeId: toStoreId, productId, quantity });\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // Record transactions\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const stores = await getStores();\n    const products = await readData<Product>(productsFilePath);\n    const fromStoreName = stores.find(s => s.id === fromStoreId)?.name || 'Unknown';\n    const toStoreName = stores.find(s => s.id === toStoreId)?.name || 'Unknown';\n    const productName = products.find(p => p.id === productId)?.itemName || 'Unknown';\n    const transferRef = `TRN-${Date.now()}`;\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-OUT`,\n        date: new Date().toISOString(),\n        storeId: fromStoreId,\n        storeName: fromStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'OUT',\n        notes: `Transfer to ${toStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-IN`,\n        date: new Date().toISOString(),\n        storeId: toStoreId,\n        storeName: toStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'IN',\n        notes: `Transfer from ${fromStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\nexport async function deleteStockTransaction(transactionId: string) {\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const transactionToDelete = allTransactions.find(t => t.id === transactionId);\n\n    if (!transactionToDelete) {\n        return { success: false, error: \"Transaction not found.\" };\n    }\n    \n    // Reverse stock level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === transactionToDelete.storeId && item.productId === transactionToDelete.productId);\n\n    if (stockItemIndex > -1) {\n        if (transactionToDelete.type === 'IN') {\n            allStock[stockItemIndex].quantity -= transactionToDelete.quantity;\n        } else { // OUT\n            allStock[stockItemIndex].quantity += transactionToDelete.quantity;\n        }\n        await writeData(stockFilePath, allStock);\n    }\n\n    // Reverse financial impact\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === transactionToDelete.productId);\n    const cost = product?.costPrice || 0;\n    const value = transactionToDelete.quantity * cost;\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140');\n\n    if (transactionToDelete.type === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance -= value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance += value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance -= value;\n        }\n    }\n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n    // Remove transaction log\n    const updatedTransactions = allTransactions.filter(t => t.id !== transactionId);\n    await writeData(stockTransactionsFilePath, updatedTransactions);\n    \n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IAwEsB,mBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 794, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/table.tsx"],"sourcesContent":["\nimport * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn(\"w-full caption-bottom text-sm\", className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n))\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\n    {...props}\n  />\n))\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      \"border-b transition-colors data-[state=selected]:bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\n    {...props}\n  />\n))\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nTableCaption.displayName = \"TableCaption\"\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AACA;AAEA;;;;AAEA,MAAM,sBAAQ,2KAAgB,MAG5B,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QAAI,WAAU;kBACb,cAAA,6LAAC;YACC,KAAK;YACL,WAAW,IAAA,4HAAE,EAAC,iCAAiC;YAC9C,GAAG,KAAK;;;;;;;;;;;;;AAIf,MAAM,WAAW,GAAG;AAEpB,MAAM,4BAAc,2KAAgB,OAGlC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QAAM,KAAK;QAAK,WAAW,IAAA,4HAAE,EAAC,mBAAmB;QAAa,GAAG,KAAK;;;;;;;;AAEzE,YAAY,WAAW,GAAG;AAE1B,MAAM,0BAAY,2KAAgB,OAGhC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,8BAA8B;QAC3C,GAAG,KAAK;;;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,4BAAc,2KAAgB,OAGlC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,2DACA;QAED,GAAG,KAAK;;;;;;;;AAGb,YAAY,WAAW,GAAG;AAE1B,MAAM,yBAAW,2KAAgB,OAG/B,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,6DACA;QAED,GAAG,KAAK;;;;;;;;AAGb,SAAS,WAAW,GAAG;AAEvB,MAAM,0BAAY,2KAAgB,QAGhC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,oGACA;QAED,GAAG,KAAK;;;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,0BAAY,2KAAgB,QAGhC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,kDAAkD;QAC/D,GAAG,KAAK;;;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,6BAAe,2KAAgB,QAGnC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QACC,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,sCAAsC;QACnD,GAAG,KAAK;;;;;;;;AAGb,aAAa,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 962, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/data-table.tsx"],"sourcesContent":["\n'use client';\n\nimport * as React from 'react';\nimport {\n  ColumnDef,\n  flexRender,\n  getCoreRowModel,\n  useReactTable,\n  getFilteredRowModel,\n  ColumnFiltersState,\n} from '@tanstack/react-table';\nimport jsPDF from 'jspdf';\nimport 'jspdf-autotable';\nimport * as XLSX from 'xlsx';\nimport { format } from 'date-fns';\n\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { FileText, FileSpreadsheet, Printer } from 'lucide-react';\nimport { useCurrency } from '@/context/currency-context';\nimport { StockItem } from './schema';\n\ndeclare module 'jspdf' {\n    interface jsPDF {\n      autoTable: (options: any) => jsPDF;\n    }\n}\n\ninterface DataTableProps<TData extends StockItem, TValue> {\n  columns: ColumnDef<TData, TValue>[];\n  data: TData[];\n  storeName: string;\n}\n\nexport function DataTable<TData extends StockItem, TValue>({\n  columns,\n  data,\n  storeName,\n}: DataTableProps<TData, TValue>) {\n  const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([]);\n  const table = useReactTable({\n    data,\n    columns,\n    getCoreRowModel: getCoreRowModel(),\n    onColumnFiltersChange: setColumnFilters,\n    getFilteredRowModel: getFilteredRowModel(),\n    state: {\n      columnFilters,\n    },\n  });\n  const { formatCurrency } = useCurrency();\n  const printRef = React.useRef<HTMLDivElement>(null);\n\n\n  const handleExportPDF = () => {\n    const doc = new jsPDF();\n    doc.text(`Stock Report for ${storeName}`, 14, 16);\n    (doc as any).autoTable({\n        head: [['Item Code', 'Item Name', 'Quantity']],\n        body: table.getFilteredRowModel().rows.map(row => [\n            row.original.itemCode,\n            row.original.itemName,\n            row.original.quantity,\n        ]),\n        startY: 20,\n    });\n    doc.save(`stock-report-${storeName}.pdf`);\n  };\n\n  const handleExportExcel = () => {\n    const dataToExport = table.getFilteredRowModel().rows.map(row => ({\n        'Item Code': row.original.itemCode,\n        'Item Name': row.original.itemName,\n        'Quantity': row.original.quantity,\n    }));\n\n    const ws = XLSX.utils.json_to_sheet(dataToExport);\n    const wb = XLSX.utils.book_new();\n    XLSX.utils.book_append_sheet(wb, ws, \"Stock\");\n    XLSX.writeFile(wb, `stock-report-${storeName}.xlsx`);\n  };\n\n  const handlePrint = () => {\n    const printContent = printRef.current?.innerHTML;\n    if (printContent) {\n        const printWindow = window.open('', '', 'height=600,width=800');\n        if (printWindow) {\n            printWindow.document.write('<html><head><title>Stock Report</title>');\n            printWindow.document.write('<style>body { font-family: sans-serif; } table { width: 100%; border-collapse: collapse; } th, td { border: 1px solid #ddd; padding: 8px; } h1 { text-align: center; } .no-print { display: none; } </style>');\n            printWindow.document.write('</head><body>');\n            printWindow.document.write(`<h1>Stock Report for ${storeName}</h1>`);\n            printWindow.document.write(printContent);\n            printWindow.document.write('</body></html>');\n            printWindow.document.close();\n            printWindow.print();\n        }\n    }\n  };\n\n  return (\n    <div>\n        <div className=\"flex items-center py-4 gap-2\">\n            <Input\n            placeholder=\"Filter by item name...\"\n            value={(table.getColumn('itemName')?.getFilterValue() as string) ?? ''}\n            onChange={(event) =>\n                table.getColumn('itemName')?.setFilterValue(event.target.value)\n            }\n            className=\"max-w-sm\"\n            />\n            <div className=\"ml-auto flex items-center gap-2\">\n                <Button variant=\"outline\" size=\"sm\" onClick={handlePrint}><Printer className=\"mr-2 h-4 w-4\" /> Print</Button>\n                <Button variant=\"outline\" size=\"sm\" onClick={handleExportPDF}><FileText className=\"mr-2 h-4 w-4\" /> PDF</Button>\n                <Button variant=\"outline\" size=\"sm\" onClick={handleExportExcel}><FileSpreadsheet className=\"mr-2 h-4 w-4\" /> Excel</Button>\n            </div>\n        </div>\n        <div ref={printRef}>\n            <div className=\"rounded-md border\">\n            <Table>\n                <TableHeader>\n                {table.getHeaderGroups().map((headerGroup) => (\n                    <TableRow key={headerGroup.id}>\n                    {headerGroup.headers.map((header) => {\n                        return (\n                        <TableHead key={header.id}>\n                            {header.isPlaceholder\n                            ? null\n                            : flexRender(\n                                header.column.columnDef.header,\n                                header.getContext()\n                                )}\n                        </TableHead>\n                        );\n                    })}\n                    </TableRow>\n                ))}\n                </TableHeader>\n                <TableBody>\n                {table.getRowModel().rows?.length ? (\n                    table.getRowModel().rows.map((row) => (\n                    <TableRow\n                        key={row.id}\n                        data-state={row.getIsSelected() && 'selected'}\n                    >\n                        {row.getVisibleCells().map((cell) => (\n                        <TableCell key={cell.id}>\n                            {flexRender(\n                            cell.column.columnDef.cell,\n                            cell.getContext()\n                            )}\n                        </TableCell>\n                        ))}\n                    </TableRow>\n                    ))\n                ) : (\n                    <TableRow>\n                    <TableCell\n                        colSpan={columns.length}\n                        className=\"h-24 text-center text-muted-foreground\"\n                    >\n                        No stock in this location.\n                    </TableCell>\n                    </TableRow>\n                )}\n                </TableBody>\n            </Table>\n            </div>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1249, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/columns.tsx"],"sourcesContent":["\n'use client';\n\nimport { ColumnDef } from '@tanstack/react-table';\nimport { type StockItem } from './schema';\n\nexport const columns: ColumnDef<StockItem>[] = [\n  {\n    accessorKey: 'itemCode',\n    header: 'Item Code',\n  },\n  {\n    accessorKey: 'itemName',\n    header: 'Item Name',\n  },\n  {\n    accessorKey: 'quantity',\n    header: () => <div className=\"text-right\">Quantity</div>,\n    cell: ({ row }) => <div className=\"text-right font-medium\">{row.original.quantity}</div>,\n  },\n];\n"],"names":[],"mappings":";;;;;AACA;;AAKO,MAAM,UAAkC;IAC7C;QACE,aAAa;QACb,QAAQ;IACV;IACA;QACE,aAAa;QACb,QAAQ;IACV;IACA;QACE,aAAa;QACb,QAAQ,kBAAM,6LAAC;gBAAI,WAAU;0BAAa;;;;;;QAC1C,MAAM;gBAAC,EAAE,GAAG,EAAE;iCAAK,6LAAC;gBAAI,WAAU;0BAA0B,IAAI,QAAQ,CAAC,QAAQ;;;;;;;IACnF;CACD","debugId":null}},
    {"offset": {"line": 1295, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { storeSchema, stockItemSchema, type Store, type StockItem, type StockTransaction } from './schema';\nimport { type Product } from '@/app/products/schema';\n\nconst storesFilePath = path.join(process.cwd(), 'src/app/stores/stores-data.json');\nconst stockFilePath = path.join(process.cwd(), 'src/app/stores/stock-data.json');\nconst stockTransactionsFilePath = path.join(process.cwd(), 'src/app/stores/stock-transactions.json');\nconst productsFilePath = path.join(process.cwd(), 'src/app/products/products-data.json');\n\n\nasync function readData<T>(filePath: string, defaultValue: T[] = []): Promise<T[]> {\n    try {\n        await fs.access(filePath);\n        const data = await fs.readFile(filePath, 'utf-8');\n        return JSON.parse(data);\n    } catch (error) {\n        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n            await fs.writeFile(filePath, JSON.stringify(defaultValue, null, 2), 'utf-8');\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n\nasync function writeData(filePath: string, data: any) {\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n}\n\n\n// Store Actions\nexport async function getStores(): Promise<Store[]> {\n    return await readData<Store>(storesFilePath);\n}\n\nexport async function saveStore(data: Omit<Store, 'id'> & { id?: string }) {\n    const validation = storeSchema.omit({id: true}).safeParse(data);\n    if (!validation.success) return { success: false, error: 'Invalid data format.' };\n\n    const stores = await getStores();\n    if (data.id) { // Update\n        const index = stores.findIndex(s => s.id === data.id);\n        if (index === -1) return { success: false, error: 'Store not found.' };\n        stores[index] = { ...stores[index], ...validation.data };\n    } else { // Create\n        const newStore: Store = { ...validation.data, id: `STORE-${Date.now()}` };\n        stores.push(newStore);\n    }\n\n    await writeData(storesFilePath, stores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\nexport async function deleteStore(storeId: string) {\n    const stores = await getStores();\n    const updatedStores = stores.filter(s => s.id !== storeId);\n    if (stores.length === updatedStores.length) {\n        return { success: false, error: 'Store not found.' };\n    }\n    await writeData(storesFilePath, updatedStores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\n// Stock Actions\nexport async function getStockForStore(storeId: string): Promise<StockItem[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const productMap = new Map(products.map(p => [p.id, p]));\n\n    return allStock\n        .filter(item => item.storeId === storeId)\n        .map(item => ({\n            ...item,\n            itemName: productMap.get(item.productId)?.itemName || 'Unknown Item',\n            itemCode: productMap.get(item.productId)?.itemCode || 'Unknown',\n        }));\n}\n\nexport async function getAggregatedStock(): Promise<any[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const stores = await getStores();\n\n    const productMap = new Map(products.map(p => [p.id, p]));\n    const storeMap = new Map(stores.map(s => [s.id, s]));\n    \n    const aggregatedStock = new Map<string, any>();\n\n    for(const item of allStock) {\n        if (!productMap.has(item.productId)) continue;\n\n        if (!aggregatedStock.has(item.productId)) {\n            const product = productMap.get(item.productId)!;\n            aggregatedStock.set(item.productId, {\n                productId: item.productId,\n                itemName: product.itemName,\n                itemCode: product.itemCode,\n                totalQuantity: 0,\n                locations: [],\n            });\n        }\n\n        const aggItem = aggregatedStock.get(item.productId)!;\n        aggItem.totalQuantity += item.quantity;\n        aggItem.locations.push({\n            storeName: storeMap.get(item.storeId)?.name || 'Unknown Store',\n            quantity: item.quantity,\n        });\n    }\n\n    return Array.from(aggregatedStock.values());\n}\n\n\nexport async function getProductsForSelect(): Promise<{value: string, label: string}[]> {\n    const products = await readData<Product>(productsFilePath);\n    return products.map(p => ({ value: p.id, label: `${p.itemName} (${p.itemCode})`}));\n}\n\n\n// Transaction Actions\nconst transactionSchema = z.object({\n    storeId: z.string(),\n    productId: z.string(),\n    quantity: z.coerce.number().min(1, 'Quantity must be at least 1.'),\n    transactionType: z.enum(['IN', 'OUT']),\n    notes: z.string().optional(),\n    jobId: z.string().optional(),\n});\n\n\nexport async function recordStockTransaction(data: z.infer<typeof transactionSchema>) {\n    const validation = transactionSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: 'Invalid data format.' };\n    }\n\n    const { storeId, productId, quantity, transactionType, notes, jobId } = validation.data;\n    \n    // 1. Update Stock Level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === storeId && item.productId === productId);\n\n    if (transactionType === 'IN') {\n        if (stockItemIndex > -1) {\n            allStock[stockItemIndex].quantity += quantity;\n        } else {\n            allStock.push({\n                id: `STOCK-${Date.now()}`,\n                storeId,\n                productId,\n                quantity,\n            });\n        }\n    } else { // OUT\n        if (stockItemIndex === -1 || allStock[stockItemIndex].quantity < quantity) {\n            return { success: false, error: 'Insufficient stock for this transaction.' };\n        }\n        allStock[stockItemIndex].quantity -= quantity;\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // 2. Record Transaction\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === productId);\n    const store = (await getStores()).find(s => s.id === storeId);\n    \n    const newTransaction: StockTransaction = {\n        id: `TXN-${Date.now()}`,\n        date: new Date().toISOString(),\n        storeId,\n        storeName: store?.name || 'Unknown Store',\n        productId,\n        productName: product?.itemName || 'Unknown Item',\n        quantity,\n        type: transactionType,\n        notes,\n        jobId\n    };\n    allTransactions.push(newTransaction);\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    // 3. Financial Impact\n    const cost = product?.costPrice || 0;\n    const value = quantity * cost;\n    \n    // This is a simplified financial integration.\n    // A more robust system would create journal entries.\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140'); // Maintenance & Repairs\n\n    if (transactionType === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) + value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) - value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance = (allAccounts[expenseAccountIndex].balance || 0) + value;\n        }\n    }\n    \n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n\n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n\nexport async function getTransactionHistory(): Promise<StockTransaction[]> {\n    return await readData<StockTransaction>(stockTransactionsFilePath);\n}\n\nconst transferSchema = z.object({\n  fromStoreId: z.string().min(1, 'Source store is required'),\n  toStoreId: z.string().min(1, 'Destination store is required'),\n  productId: z.string().min(1, 'Product is required'),\n  quantity: z.coerce.number().min(1, 'Quantity must be at least 1'),\n  notes: z.string().optional(),\n}).refine(data => data.fromStoreId !== data.toStoreId, {\n    message: \"Source and destination stores cannot be the same.\",\n    path: ['toStoreId'],\n});\n\nexport async function transferStock(data: z.infer<typeof transferSchema>) {\n    const validation = transferSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: validation.error.errors[0].message };\n    }\n\n    const { fromStoreId, toStoreId, productId, quantity, notes } = validation.data;\n    \n    const allStock = await readData<StockItem>(stockFilePath);\n    const sourceStockIndex = allStock.findIndex(item => item.storeId === fromStoreId && item.productId === productId);\n    \n    // Check for sufficient stock\n    if (sourceStockIndex === -1 || allStock[sourceStockIndex].quantity < quantity) {\n        return { success: false, error: 'Insufficient stock in the source store.' };\n    }\n\n    // Decrement from source\n    allStock[sourceStockIndex].quantity -= quantity;\n\n    // Increment in destination\n    const destinationStockIndex = allStock.findIndex(item => item.storeId === toStoreId && item.productId === productId);\n    if (destinationStockIndex > -1) {\n        allStock[destinationStockIndex].quantity += quantity;\n    } else {\n        allStock.push({ id: `STOCK-${Date.now()}`, storeId: toStoreId, productId, quantity });\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // Record transactions\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const stores = await getStores();\n    const products = await readData<Product>(productsFilePath);\n    const fromStoreName = stores.find(s => s.id === fromStoreId)?.name || 'Unknown';\n    const toStoreName = stores.find(s => s.id === toStoreId)?.name || 'Unknown';\n    const productName = products.find(p => p.id === productId)?.itemName || 'Unknown';\n    const transferRef = `TRN-${Date.now()}`;\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-OUT`,\n        date: new Date().toISOString(),\n        storeId: fromStoreId,\n        storeName: fromStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'OUT',\n        notes: `Transfer to ${toStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-IN`,\n        date: new Date().toISOString(),\n        storeId: toStoreId,\n        storeName: toStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'IN',\n        notes: `Transfer from ${fromStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\nexport async function deleteStockTransaction(transactionId: string) {\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const transactionToDelete = allTransactions.find(t => t.id === transactionId);\n\n    if (!transactionToDelete) {\n        return { success: false, error: \"Transaction not found.\" };\n    }\n    \n    // Reverse stock level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === transactionToDelete.storeId && item.productId === transactionToDelete.productId);\n\n    if (stockItemIndex > -1) {\n        if (transactionToDelete.type === 'IN') {\n            allStock[stockItemIndex].quantity -= transactionToDelete.quantity;\n        } else { // OUT\n            allStock[stockItemIndex].quantity += transactionToDelete.quantity;\n        }\n        await writeData(stockFilePath, allStock);\n    }\n\n    // Reverse financial impact\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === transactionToDelete.productId);\n    const cost = product?.costPrice || 0;\n    const value = transactionToDelete.quantity * cost;\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140');\n\n    if (transactionToDelete.type === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance -= value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance += value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance -= value;\n        }\n    }\n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n    // Remove transaction log\n    const updatedTransactions = allTransactions.filter(t => t.id !== transactionId);\n    await writeData(stockTransactionsFilePath, updatedTransactions);\n    \n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IA0HsB,uBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 1310, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { storeSchema, stockItemSchema, type Store, type StockItem, type StockTransaction } from './schema';\nimport { type Product } from '@/app/products/schema';\n\nconst storesFilePath = path.join(process.cwd(), 'src/app/stores/stores-data.json');\nconst stockFilePath = path.join(process.cwd(), 'src/app/stores/stock-data.json');\nconst stockTransactionsFilePath = path.join(process.cwd(), 'src/app/stores/stock-transactions.json');\nconst productsFilePath = path.join(process.cwd(), 'src/app/products/products-data.json');\n\n\nasync function readData<T>(filePath: string, defaultValue: T[] = []): Promise<T[]> {\n    try {\n        await fs.access(filePath);\n        const data = await fs.readFile(filePath, 'utf-8');\n        return JSON.parse(data);\n    } catch (error) {\n        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n            await fs.writeFile(filePath, JSON.stringify(defaultValue, null, 2), 'utf-8');\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n\nasync function writeData(filePath: string, data: any) {\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n}\n\n\n// Store Actions\nexport async function getStores(): Promise<Store[]> {\n    return await readData<Store>(storesFilePath);\n}\n\nexport async function saveStore(data: Omit<Store, 'id'> & { id?: string }) {\n    const validation = storeSchema.omit({id: true}).safeParse(data);\n    if (!validation.success) return { success: false, error: 'Invalid data format.' };\n\n    const stores = await getStores();\n    if (data.id) { // Update\n        const index = stores.findIndex(s => s.id === data.id);\n        if (index === -1) return { success: false, error: 'Store not found.' };\n        stores[index] = { ...stores[index], ...validation.data };\n    } else { // Create\n        const newStore: Store = { ...validation.data, id: `STORE-${Date.now()}` };\n        stores.push(newStore);\n    }\n\n    await writeData(storesFilePath, stores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\nexport async function deleteStore(storeId: string) {\n    const stores = await getStores();\n    const updatedStores = stores.filter(s => s.id !== storeId);\n    if (stores.length === updatedStores.length) {\n        return { success: false, error: 'Store not found.' };\n    }\n    await writeData(storesFilePath, updatedStores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\n// Stock Actions\nexport async function getStockForStore(storeId: string): Promise<StockItem[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const productMap = new Map(products.map(p => [p.id, p]));\n\n    return allStock\n        .filter(item => item.storeId === storeId)\n        .map(item => ({\n            ...item,\n            itemName: productMap.get(item.productId)?.itemName || 'Unknown Item',\n            itemCode: productMap.get(item.productId)?.itemCode || 'Unknown',\n        }));\n}\n\nexport async function getAggregatedStock(): Promise<any[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const stores = await getStores();\n\n    const productMap = new Map(products.map(p => [p.id, p]));\n    const storeMap = new Map(stores.map(s => [s.id, s]));\n    \n    const aggregatedStock = new Map<string, any>();\n\n    for(const item of allStock) {\n        if (!productMap.has(item.productId)) continue;\n\n        if (!aggregatedStock.has(item.productId)) {\n            const product = productMap.get(item.productId)!;\n            aggregatedStock.set(item.productId, {\n                productId: item.productId,\n                itemName: product.itemName,\n                itemCode: product.itemCode,\n                totalQuantity: 0,\n                locations: [],\n            });\n        }\n\n        const aggItem = aggregatedStock.get(item.productId)!;\n        aggItem.totalQuantity += item.quantity;\n        aggItem.locations.push({\n            storeName: storeMap.get(item.storeId)?.name || 'Unknown Store',\n            quantity: item.quantity,\n        });\n    }\n\n    return Array.from(aggregatedStock.values());\n}\n\n\nexport async function getProductsForSelect(): Promise<{value: string, label: string}[]> {\n    const products = await readData<Product>(productsFilePath);\n    return products.map(p => ({ value: p.id, label: `${p.itemName} (${p.itemCode})`}));\n}\n\n\n// Transaction Actions\nconst transactionSchema = z.object({\n    storeId: z.string(),\n    productId: z.string(),\n    quantity: z.coerce.number().min(1, 'Quantity must be at least 1.'),\n    transactionType: z.enum(['IN', 'OUT']),\n    notes: z.string().optional(),\n    jobId: z.string().optional(),\n});\n\n\nexport async function recordStockTransaction(data: z.infer<typeof transactionSchema>) {\n    const validation = transactionSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: 'Invalid data format.' };\n    }\n\n    const { storeId, productId, quantity, transactionType, notes, jobId } = validation.data;\n    \n    // 1. Update Stock Level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === storeId && item.productId === productId);\n\n    if (transactionType === 'IN') {\n        if (stockItemIndex > -1) {\n            allStock[stockItemIndex].quantity += quantity;\n        } else {\n            allStock.push({\n                id: `STOCK-${Date.now()}`,\n                storeId,\n                productId,\n                quantity,\n            });\n        }\n    } else { // OUT\n        if (stockItemIndex === -1 || allStock[stockItemIndex].quantity < quantity) {\n            return { success: false, error: 'Insufficient stock for this transaction.' };\n        }\n        allStock[stockItemIndex].quantity -= quantity;\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // 2. Record Transaction\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === productId);\n    const store = (await getStores()).find(s => s.id === storeId);\n    \n    const newTransaction: StockTransaction = {\n        id: `TXN-${Date.now()}`,\n        date: new Date().toISOString(),\n        storeId,\n        storeName: store?.name || 'Unknown Store',\n        productId,\n        productName: product?.itemName || 'Unknown Item',\n        quantity,\n        type: transactionType,\n        notes,\n        jobId\n    };\n    allTransactions.push(newTransaction);\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    // 3. Financial Impact\n    const cost = product?.costPrice || 0;\n    const value = quantity * cost;\n    \n    // This is a simplified financial integration.\n    // A more robust system would create journal entries.\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140'); // Maintenance & Repairs\n\n    if (transactionType === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) + value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) - value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance = (allAccounts[expenseAccountIndex].balance || 0) + value;\n        }\n    }\n    \n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n\n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n\nexport async function getTransactionHistory(): Promise<StockTransaction[]> {\n    return await readData<StockTransaction>(stockTransactionsFilePath);\n}\n\nconst transferSchema = z.object({\n  fromStoreId: z.string().min(1, 'Source store is required'),\n  toStoreId: z.string().min(1, 'Destination store is required'),\n  productId: z.string().min(1, 'Product is required'),\n  quantity: z.coerce.number().min(1, 'Quantity must be at least 1'),\n  notes: z.string().optional(),\n}).refine(data => data.fromStoreId !== data.toStoreId, {\n    message: \"Source and destination stores cannot be the same.\",\n    path: ['toStoreId'],\n});\n\nexport async function transferStock(data: z.infer<typeof transferSchema>) {\n    const validation = transferSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: validation.error.errors[0].message };\n    }\n\n    const { fromStoreId, toStoreId, productId, quantity, notes } = validation.data;\n    \n    const allStock = await readData<StockItem>(stockFilePath);\n    const sourceStockIndex = allStock.findIndex(item => item.storeId === fromStoreId && item.productId === productId);\n    \n    // Check for sufficient stock\n    if (sourceStockIndex === -1 || allStock[sourceStockIndex].quantity < quantity) {\n        return { success: false, error: 'Insufficient stock in the source store.' };\n    }\n\n    // Decrement from source\n    allStock[sourceStockIndex].quantity -= quantity;\n\n    // Increment in destination\n    const destinationStockIndex = allStock.findIndex(item => item.storeId === toStoreId && item.productId === productId);\n    if (destinationStockIndex > -1) {\n        allStock[destinationStockIndex].quantity += quantity;\n    } else {\n        allStock.push({ id: `STOCK-${Date.now()}`, storeId: toStoreId, productId, quantity });\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // Record transactions\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const stores = await getStores();\n    const products = await readData<Product>(productsFilePath);\n    const fromStoreName = stores.find(s => s.id === fromStoreId)?.name || 'Unknown';\n    const toStoreName = stores.find(s => s.id === toStoreId)?.name || 'Unknown';\n    const productName = products.find(p => p.id === productId)?.itemName || 'Unknown';\n    const transferRef = `TRN-${Date.now()}`;\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-OUT`,\n        date: new Date().toISOString(),\n        storeId: fromStoreId,\n        storeName: fromStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'OUT',\n        notes: `Transfer to ${toStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-IN`,\n        date: new Date().toISOString(),\n        storeId: toStoreId,\n        storeName: toStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'IN',\n        notes: `Transfer from ${fromStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\nexport async function deleteStockTransaction(transactionId: string) {\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const transactionToDelete = allTransactions.find(t => t.id === transactionId);\n\n    if (!transactionToDelete) {\n        return { success: false, error: \"Transaction not found.\" };\n    }\n    \n    // Reverse stock level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === transactionToDelete.storeId && item.productId === transactionToDelete.productId);\n\n    if (stockItemIndex > -1) {\n        if (transactionToDelete.type === 'IN') {\n            allStock[stockItemIndex].quantity -= transactionToDelete.quantity;\n        } else { // OUT\n            allStock[stockItemIndex].quantity += transactionToDelete.quantity;\n        }\n        await writeData(stockFilePath, allStock);\n    }\n\n    // Reverse financial impact\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === transactionToDelete.productId);\n    const cost = product?.costPrice || 0;\n    const value = transactionToDelete.quantity * cost;\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140');\n\n    if (transactionToDelete.type === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance -= value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance += value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance -= value;\n        }\n    }\n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n    // Remove transaction log\n    const updatedTransactions = allTransactions.filter(t => t.id !== transactionId);\n    await writeData(stockTransactionsFilePath, updatedTransactions);\n    \n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IA2IsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 1325, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/command.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport { type DialogProps } from \"@radix-ui/react-dialog\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { Search } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent } from \"@/components/ui/dialog\"\n\nconst Command = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nCommand.displayName = CommandPrimitive.displayName\n\ninterface CommandDialogProps extends DialogProps {}\n\nconst CommandDialog = ({ children, ...props }: CommandDialogProps) => {\n  return (\n    <Dialog {...props}>\n      <DialogContent className=\"overflow-hidden p-0 shadow-lg\">\n        <Command className=\"[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n          {children}\n        </Command>\n      </DialogContent>\n    </Dialog>\n  )\n}\n\nconst CommandInput = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Input>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>\n>(({ className, ...props }, ref) => (\n  <div className=\"flex items-center border-b px-3\" cmdk-input-wrapper=\"\">\n    <Search className=\"mr-2 h-4 w-4 shrink-0 opacity-50\" />\n    <CommandPrimitive.Input\n      ref={ref}\n      className={cn(\n        \"flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  </div>\n))\n\nCommandInput.displayName = CommandPrimitive.Input.displayName\n\nconst CommandList = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.List\n    ref={ref}\n    className={cn(\"max-h-[300px] overflow-y-auto overflow-x-hidden\", className)}\n    {...props}\n  />\n))\n\nCommandList.displayName = CommandPrimitive.List.displayName\n\nconst CommandEmpty = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Empty>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>\n>((props, ref) => (\n  <CommandPrimitive.Empty\n    ref={ref}\n    className=\"py-6 text-center text-sm\"\n    {...props}\n  />\n))\n\nCommandEmpty.displayName = CommandPrimitive.Empty.displayName\n\nconst CommandGroup = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Group>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Group\n    ref={ref}\n    className={cn(\n      \"overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandGroup.displayName = CommandPrimitive.Group.displayName\n\nconst CommandSeparator = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nCommandSeparator.displayName = CommandPrimitive.Separator.displayName\n\nconst CommandItem = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none aria-selected:bg-accent aria-selected:text-accent-foreground data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandItem.displayName = CommandPrimitive.Item.displayName\n\nconst CommandShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nCommandShortcut.displayName = \"CommandShortcut\"\n\nexport {\n  Command,\n  CommandDialog,\n  CommandInput,\n  CommandList,\n  CommandEmpty,\n  CommandGroup,\n  CommandItem,\n  CommandShortcut,\n  CommandSeparator,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAEA;AAEA;AACA;AAEA;AACA;AARA;;;;;;;AAUA,MAAM,wBAAU,2KAAgB,CAG9B,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,oJAAgB;QACf,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,6FACA;QAED,GAAG,KAAK;;;;;;;KAVP;AAaN,QAAQ,WAAW,GAAG,oJAAgB,CAAC,WAAW;AAIlD,MAAM,gBAAgB;QAAC,EAAE,QAAQ,EAAE,GAAG,OAA2B;IAC/D,qBACE,6LAAC,+IAAM;QAAE,GAAG,KAAK;kBACf,cAAA,6LAAC,sJAAa;YAAC,WAAU;sBACvB,cAAA,6LAAC;gBAAQ,WAAU;0BAChB;;;;;;;;;;;;;;;;AAKX;MAVM;AAYN,MAAM,6BAAe,2KAAgB,OAGnC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC;QAAI,WAAU;QAAkC,sBAAmB;;0BAClE,6LAAC,mNAAM;gBAAC,WAAU;;;;;;0BAClB,6LAAC,oJAAgB,CAAC,KAAK;gBACrB,KAAK;gBACL,WAAW,IAAA,4HAAE,EACX,0JACA;gBAED,GAAG,KAAK;;;;;;;;;;;;;;AAKf,aAAa,WAAW,GAAG,oJAAgB,CAAC,KAAK,CAAC,WAAW;AAE7D,MAAM,4BAAc,2KAAgB,OAGlC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,oJAAgB,CAAC,IAAI;QACpB,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,mDAAmD;QAChE,GAAG,KAAK;;;;;;;;AAIb,YAAY,WAAW,GAAG,oJAAgB,CAAC,IAAI,CAAC,WAAW;AAE3D,MAAM,6BAAe,2KAAgB,OAGnC,CAAC,OAAO,oBACR,6LAAC,oJAAgB,CAAC,KAAK;QACrB,KAAK;QACL,WAAU;QACT,GAAG,KAAK;;;;;;;AAIb,aAAa,WAAW,GAAG,oJAAgB,CAAC,KAAK,CAAC,WAAW;AAE7D,MAAM,6BAAe,2KAAgB,OAGnC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,oJAAgB,CAAC,KAAK;QACrB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,0NACA;QAED,GAAG,KAAK;;;;;;;;AAIb,aAAa,WAAW,GAAG,oJAAgB,CAAC,KAAK,CAAC,WAAW;AAE7D,MAAM,iCAAmB,2KAAgB,QAGvC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,oJAAgB,CAAC,SAAS;QACzB,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,wBAAwB;QACrC,GAAG,KAAK;;;;;;;;AAGb,iBAAiB,WAAW,GAAG,oJAAgB,CAAC,SAAS,CAAC,WAAW;AAErE,MAAM,4BAAc,2KAAgB,QAGlC,QAA0B;QAAzB,EAAE,SAAS,EAAE,GAAG,OAAO;yBACxB,6LAAC,oJAAgB,CAAC,IAAI;QACpB,KAAK;QACL,WAAW,IAAA,4HAAE,EACX,2OACA;QAED,GAAG,KAAK;;;;;;;;AAIb,YAAY,WAAW,GAAG,oJAAgB,CAAC,IAAI,CAAC,WAAW;AAE3D,MAAM,kBAAkB;QAAC,EACvB,SAAS,EACT,GAAG,OACmC;IACtC,qBACE,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,yDACA;QAED,GAAG,KAAK;;;;;;AAGf;OAbM;AAcN,gBAAgB,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 1533, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/popover.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Popover = PopoverPrimitive.Root\n\nconst PopoverTrigger = PopoverPrimitive.Trigger\n\nconst PopoverContent = React.forwardRef<\n  React.ElementRef<typeof PopoverPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <PopoverPrimitive.Portal>\n    <PopoverPrimitive.Content\n      ref={ref}\n      align={align}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </PopoverPrimitive.Portal>\n))\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\n\nexport { Popover, PopoverTrigger, PopoverContent }\n"],"names":[],"mappings":";;;;;;;;;AAEA;AACA;AAEA;AALA;;;;;AAOA,MAAM,UAAU,8KAAqB;AAErC,MAAM,iBAAiB,iLAAwB;AAE/C,MAAM,+BAAiB,2KAAgB,MAGrC,QAA4D;QAA3D,EAAE,SAAS,EAAE,QAAQ,QAAQ,EAAE,aAAa,CAAC,EAAE,GAAG,OAAO;yBAC1D,6LAAC,gLAAuB;kBACtB,cAAA,6LAAC,iLAAwB;YACvB,KAAK;YACL,OAAO;YACP,YAAY;YACZ,WAAW,IAAA,4HAAE,EACX,8aACA;YAED,GAAG,KAAK;;;;;;;;;;;;;AAIf,eAAe,WAAW,GAAG,iLAAwB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 1585, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/combobox.tsx"],"sourcesContent":["\n\"use client\"\n\nimport * as React from \"react\"\nimport { Check, ChevronsUpDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/components/ui/command\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\nimport { Input } from \"./input\"\n\ntype ComboboxProps = {\n    options?: { value: string; label: string }[];\n    value: string;\n    onSelect: (value: string, label?: string) => void;\n    placeholder?: string;\n    disabled?: boolean;\n}\n\nexport function Combobox({ options = [], value, onSelect, placeholder, disabled }: ComboboxProps) {\n  const [open, setOpen] = React.useState(false)\n  const [inputValue, setInputValue] = React.useState(\"\")\n\n  const selectedOption = options.find((option) => \n    (option.value?.toLowerCase() === value?.toLowerCase())\n  );\n  \n  React.useEffect(() => {\n    setInputValue(selectedOption?.label || value || '')\n  }, [value, selectedOption])\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"outline\"\n          role=\"combobox\"\n          aria-expanded={open}\n          className=\"w-full justify-between font-normal\"\n          disabled={disabled}\n        >\n          <span className=\"truncate\">\n            {selectedOption?.label || value || placeholder || \"Select option...\"}\n          </span>\n          <ChevronsUpDown className=\"ml-2 h-4 w-4 shrink-0 opacity-50\" />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-[--radix-popover-trigger-width] p-0\">\n        <Command>\n          <CommandInput \n            placeholder=\"Search or enter new...\"\n            value={inputValue}\n            onValueChange={setInputValue}\n           />\n          <CommandList>\n            <CommandEmpty onSelect={() => {\n                onSelect(inputValue, inputValue)\n                setOpen(false)\n            }}>\n                <div \n                    className=\"py-2 px-4 text-sm cursor-pointer hover:bg-accent\"\n                    onClick={() => {\n                         onSelect(inputValue, inputValue)\n                         setOpen(false)\n                    }}\n                >\n                    Add new: \"{inputValue}\"\n                </div>\n            </CommandEmpty>\n            <CommandGroup>\n              {options.map((option, index) => (\n                <CommandItem\n                  key={`${option.value}-${index}`}\n                  value={option.label}\n                  onSelect={(currentLabel) => {\n                    const selected = options.find(opt => opt.label.toLowerCase() === currentLabel.toLowerCase())\n                    onSelect(selected?.value || currentLabel, selected?.label || currentLabel)\n                    setOpen(false)\n                  }}\n                >\n                  <Check\n                    className={cn(\n                      \"mr-2 h-4 w-4\",\n                      value === option.value ? \"opacity-100\" : \"opacity-0\"\n                    )}\n                  />\n                  {option.label}\n                </CommandItem>\n              ))}\n            </CommandGroup>\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  )\n}\n"],"names":[],"mappings":";;;;;AAGA;AACA;AAAA;AAEA;AACA;AACA;AAQA;;;AAfA;;;;;;;AA8BO,SAAS,SAAS,KAAuE;QAAvE,EAAE,UAAU,EAAE,EAAE,KAAK,EAAE,QAAQ,EAAE,WAAW,EAAE,QAAQ,EAAiB,GAAvE;;IACvB,MAAM,CAAC,MAAM,QAAQ,GAAG,yKAAc,CAAC;IACvC,MAAM,CAAC,YAAY,cAAc,GAAG,yKAAc,CAAC;IAEnD,MAAM,iBAAiB,QAAQ,IAAI,CAAC,CAAC;YAClC;eAAA,EAAA,gBAAA,OAAO,KAAK,cAAZ,oCAAA,cAAc,WAAW,SAAO,kBAAA,4BAAA,MAAO,WAAW;;IAGrD,0KAAe;8BAAC;YACd,cAAc,CAAA,2BAAA,qCAAA,eAAgB,KAAK,KAAI,SAAS;QAClD;6BAAG;QAAC;QAAO;KAAe;IAE1B,qBACE,6LAAC,iJAAO;QAAC,MAAM;QAAM,cAAc;;0BACjC,6LAAC,wJAAc;gBAAC,OAAO;0BACrB,cAAA,6LAAC,+IAAM;oBACL,SAAQ;oBACR,MAAK;oBACL,iBAAe;oBACf,WAAU;oBACV,UAAU;;sCAEV,6LAAC;4BAAK,WAAU;sCACb,CAAA,2BAAA,qCAAA,eAAgB,KAAK,KAAI,SAAS,eAAe;;;;;;sCAEpD,6LAAC,mPAAc;4BAAC,WAAU;;;;;;;;;;;;;;;;;0BAG9B,6LAAC,wJAAc;gBAAC,WAAU;0BACxB,cAAA,6LAAC,iJAAO;;sCACN,6LAAC,sJAAY;4BACX,aAAY;4BACZ,OAAO;4BACP,eAAe;;;;;;sCAEjB,6LAAC,qJAAW;;8CACV,6LAAC,sJAAY;oCAAC,UAAU;wCACpB,SAAS,YAAY;wCACrB,QAAQ;oCACZ;8CACI,cAAA,6LAAC;wCACG,WAAU;wCACV,SAAS;4CACJ,SAAS,YAAY;4CACrB,QAAQ;wCACb;;4CACH;4CACc;4CAAW;;;;;;;;;;;;8CAG9B,6LAAC,sJAAY;8CACV,QAAQ,GAAG,CAAC,CAAC,QAAQ,sBACpB,6LAAC,qJAAW;4CAEV,OAAO,OAAO,KAAK;4CACnB,UAAU,CAAC;gDACT,MAAM,WAAW,QAAQ,IAAI,CAAC,CAAA,MAAO,IAAI,KAAK,CAAC,WAAW,OAAO,aAAa,WAAW;gDACzF,SAAS,CAAA,qBAAA,+BAAA,SAAU,KAAK,KAAI,cAAc,CAAA,qBAAA,+BAAA,SAAU,KAAK,KAAI;gDAC7D,QAAQ;4CACV;;8DAEA,6LAAC,gNAAK;oDACJ,WAAW,kIACT,gBACA,UAAU,OAAO,KAAK,GAAG,gBAAgB;;;;;;gDAG5C,OAAO,KAAK;;2CAdR,AAAC,GAAkB,OAAhB,OAAO,KAAK,EAAC,KAAS,OAAN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuB1C;GA5EgB;KAAA","debugId":null}},
    {"offset": {"line": 1766, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/textarea.tsx"],"sourcesContent":["import * as React from 'react';\n\nimport {cn} from '@/lib/utils';\n\nexport interface TextareaProps\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\n\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\n  ({className, ...props}, ref) => {\n    return (\n      <textarea\n        className={cn(\n          'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    );\n  }\n);\nTextarea.displayName = 'Textarea';\n\nexport {Textarea};\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAKA,MAAM,yBAAW,2KAAgB,MAC/B,QAAwB;QAAvB,EAAC,SAAS,EAAE,GAAG,OAAM;IACpB,qBACE,6LAAC;QACC,WAAW,IAAA,4HAAE,EACX,qTACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,SAAS,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 1801, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/stock-in-dialog.tsx"],"sourcesContent":["\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n  DialogClose,\n} from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { useToast } from '@/hooks/use-toast';\nimport { Loader2 } from 'lucide-react';\nimport { useForm, Controller } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { getProductsForSelect, recordStockTransaction } from './actions';\nimport { type Store } from './schema';\nimport { Combobox } from '@/components/ui/combobox';\nimport { Textarea } from '@/components/ui/textarea';\n\n\nconst formSchema = z.object({\n  productId: z.string().min(1, 'Please select a product.'),\n  quantity: z.coerce.number().min(1, 'Quantity must be at least 1.'),\n  notes: z.string().optional(),\n});\n\ntype FormData = z.infer<typeof formSchema>;\n\ninterface StockInDialogProps {\n  isOpen: boolean;\n  setIsOpen: (open: boolean) => void;\n  store: Store;\n  onSuccess: () => void;\n}\n\nexport function StockInDialog({ isOpen, setIsOpen, store, onSuccess }: StockInDialogProps) {\n  const [isSaving, setIsSaving] = useState(false);\n  const [products, setProducts] = useState<{value: string, label: string}[]>([]);\n  const { toast } = useToast();\n\n  const {\n    register,\n    handleSubmit,\n    control,\n    reset,\n    formState: { errors },\n  } = useForm<FormData>({\n    resolver: zodResolver(formSchema),\n    defaultValues: { quantity: 1 }\n  });\n\n  useEffect(() => {\n    if (isOpen) {\n        getProductsForSelect().then(setProducts);\n        reset({ quantity: 1, productId: '', notes: '' });\n    }\n  }, [isOpen, reset]);\n\n  const onSubmit = async (data: FormData) => {\n    setIsSaving(true);\n    const result = await recordStockTransaction({\n        ...data,\n        storeId: store.id,\n        transactionType: 'IN',\n    });\n\n    if (result.success) {\n      toast({\n        title: 'Stock Added',\n        description: 'Inventory has been updated successfully.',\n      });\n      onSuccess();\n      setIsOpen(false);\n    } else {\n      toast({\n        variant: 'destructive',\n        title: 'Error',\n        description: result.error,\n      });\n    }\n    setIsSaving(false);\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={setIsOpen}>\n      <DialogContent>\n        <form onSubmit={handleSubmit(onSubmit)}>\n            <DialogHeader>\n            <DialogTitle>Stock In: {store.name}</DialogTitle>\n            <DialogDescription>\n                Record new items being added to this store's inventory.\n            </DialogDescription>\n            </DialogHeader>\n            <div className=\"grid gap-4 py-4\">\n                <div className=\"space-y-2\">\n                    <Label htmlFor=\"productId\">Product / Service</Label>\n                     <Controller\n                        name=\"productId\"\n                        control={control}\n                        render={({ field }) => (\n                           <Combobox\n                                options={products}\n                                value={field.value || ''}\n                                onSelect={field.onChange}\n                                placeholder=\"Select an item\"\n                           />\n                        )}\n                    />\n                    {errors.productId && <p className=\"text-destructive text-xs mt-1\">{errors.productId.message}</p>}\n                </div>\n                 <div className=\"space-y-2\">\n                    <Label htmlFor=\"quantity\">Quantity</Label>\n                    <Input id=\"quantity\" type=\"number\" {...register('quantity')} />\n                    {errors.quantity && <p className=\"text-destructive text-xs mt-1\">{errors.quantity.message}</p>}\n                </div>\n                 <div className=\"space-y-2\">\n                    <Label htmlFor=\"notes\">Notes / Reference</Label>\n                    <Textarea id=\"notes\" {...register('notes')} placeholder=\"e.g., PO #123, Initial stock\" />\n                </div>\n            </div>\n            <DialogFooter>\n                <DialogClose asChild>\n                    <Button type=\"button\" variant=\"outline\">Cancel</Button>\n                </DialogClose>\n                <Button type=\"submit\" disabled={isSaving}>\n                    {isSaving && <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />}\n                    Add Stock\n                </Button>\n            </DialogFooter>\n        </form>\n      </DialogContent>\n    </Dialog>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2113, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/stock-out-dialog.tsx"],"sourcesContent":["\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n  DialogClose,\n} from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { useToast } from '@/hooks/use-toast';\nimport { Loader2 } from 'lucide-react';\nimport { useForm, Controller } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { getProductsForSelect, recordStockTransaction } from './actions';\nimport { type Store } from './schema';\nimport { Combobox } from '@/components/ui/combobox';\nimport { Textarea } from '@/components/ui/textarea';\n\n\nconst formSchema = z.object({\n  productId: z.string().min(1, 'Please select a product.'),\n  quantity: z.coerce.number().min(1, 'Quantity must be at least 1.'),\n  notes: z.string().optional(),\n  jobId: z.string().optional(),\n});\n\ntype FormData = z.infer<typeof formSchema>;\n\ninterface StockOutDialogProps {\n  isOpen: boolean;\n  setIsOpen: (open: boolean) => void;\n  store: Store;\n  onSuccess: () => void;\n}\n\nexport function StockOutDialog({ isOpen, setIsOpen, store, onSuccess }: StockOutDialogProps) {\n  const [isSaving, setIsSaving] = useState(false);\n  const [products, setProducts] = useState<{value: string, label: string}[]>([]);\n  const { toast } = useToast();\n\n  const {\n    register,\n    handleSubmit,\n    control,\n    reset,\n    formState: { errors },\n  } = useForm<FormData>({\n    resolver: zodResolver(formSchema),\n     defaultValues: { quantity: 1 }\n  });\n\n  useEffect(() => {\n    if (isOpen) {\n        getProductsForSelect().then(setProducts);\n        reset({ quantity: 1, productId: '', notes: '', jobId: '' });\n    }\n  }, [isOpen, reset]);\n\n  const onSubmit = async (data: FormData) => {\n    setIsSaving(true);\n    const result = await recordStockTransaction({\n        ...data,\n        storeId: store.id,\n        transactionType: 'OUT',\n    });\n\n    if (result.success) {\n      toast({\n        title: 'Stock Issued',\n        description: 'Inventory has been updated successfully.',\n      });\n      onSuccess();\n      setIsOpen(false);\n    } else {\n      toast({\n        variant: 'destructive',\n        title: 'Error',\n        description: result.error,\n      });\n    }\n    setIsSaving(false);\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={setIsOpen}>\n      <DialogContent>\n        <form onSubmit={handleSubmit(onSubmit)}>\n            <DialogHeader>\n            <DialogTitle>Stock Out: {store.name}</DialogTitle>\n            <DialogDescription>\n                Record items being issued from this store for a job or project.\n            </DialogDescription>\n            </DialogHeader>\n            <div className=\"grid gap-4 py-4\">\n                <div className=\"space-y-2\">\n                    <Label htmlFor=\"productId\">Product / Service</Label>\n                     <Controller\n                        name=\"productId\"\n                        control={control}\n                        render={({ field }) => (\n                           <Combobox\n                                options={products}\n                                value={field.value || ''}\n                                onSelect={field.onChange}\n                                placeholder=\"Select an item\"\n                           />\n                        )}\n                    />\n                    {errors.productId && <p className=\"text-destructive text-xs mt-1\">{errors.productId.message}</p>}\n                </div>\n                 <div className=\"space-y-2\">\n                    <Label htmlFor=\"quantity\">Quantity</Label>\n                    <Input id=\"quantity\" type=\"number\" {...register('quantity')} />\n                    {errors.quantity && <p className=\"text-destructive text-xs mt-1\">{errors.quantity.message}</p>}\n                </div>\n                 <div className=\"space-y-2\">\n                    <Label htmlFor=\"jobId\">Job / Maintenance Ticket ID</Label>\n                    <Input id=\"jobId\" {...register('jobId')} placeholder=\"e.g. M-0012, Project X\" />\n                </div>\n                 <div className=\"space-y-2\">\n                    <Label htmlFor=\"notes\">Notes / Remarks</Label>\n                    <Textarea id=\"notes\" {...register('notes')} placeholder=\"e.g., Issued to John Doe\" />\n                </div>\n            </div>\n            <DialogFooter>\n                <DialogClose asChild>\n                    <Button type=\"button\" variant=\"outline\">Cancel</Button>\n                </DialogClose>\n                <Button type=\"submit\" disabled={isSaving}>\n                    {isSaving && <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />}\n                    Issue Stock\n                </Button>\n            </DialogFooter>\n        </form>\n      </DialogContent>\n    </Dialog>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2453, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { storeSchema, stockItemSchema, type Store, type StockItem, type StockTransaction } from './schema';\nimport { type Product } from '@/app/products/schema';\n\nconst storesFilePath = path.join(process.cwd(), 'src/app/stores/stores-data.json');\nconst stockFilePath = path.join(process.cwd(), 'src/app/stores/stock-data.json');\nconst stockTransactionsFilePath = path.join(process.cwd(), 'src/app/stores/stock-transactions.json');\nconst productsFilePath = path.join(process.cwd(), 'src/app/products/products-data.json');\n\n\nasync function readData<T>(filePath: string, defaultValue: T[] = []): Promise<T[]> {\n    try {\n        await fs.access(filePath);\n        const data = await fs.readFile(filePath, 'utf-8');\n        return JSON.parse(data);\n    } catch (error) {\n        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n            await fs.writeFile(filePath, JSON.stringify(defaultValue, null, 2), 'utf-8');\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n\nasync function writeData(filePath: string, data: any) {\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n}\n\n\n// Store Actions\nexport async function getStores(): Promise<Store[]> {\n    return await readData<Store>(storesFilePath);\n}\n\nexport async function saveStore(data: Omit<Store, 'id'> & { id?: string }) {\n    const validation = storeSchema.omit({id: true}).safeParse(data);\n    if (!validation.success) return { success: false, error: 'Invalid data format.' };\n\n    const stores = await getStores();\n    if (data.id) { // Update\n        const index = stores.findIndex(s => s.id === data.id);\n        if (index === -1) return { success: false, error: 'Store not found.' };\n        stores[index] = { ...stores[index], ...validation.data };\n    } else { // Create\n        const newStore: Store = { ...validation.data, id: `STORE-${Date.now()}` };\n        stores.push(newStore);\n    }\n\n    await writeData(storesFilePath, stores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\nexport async function deleteStore(storeId: string) {\n    const stores = await getStores();\n    const updatedStores = stores.filter(s => s.id !== storeId);\n    if (stores.length === updatedStores.length) {\n        return { success: false, error: 'Store not found.' };\n    }\n    await writeData(storesFilePath, updatedStores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\n// Stock Actions\nexport async function getStockForStore(storeId: string): Promise<StockItem[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const productMap = new Map(products.map(p => [p.id, p]));\n\n    return allStock\n        .filter(item => item.storeId === storeId)\n        .map(item => ({\n            ...item,\n            itemName: productMap.get(item.productId)?.itemName || 'Unknown Item',\n            itemCode: productMap.get(item.productId)?.itemCode || 'Unknown',\n        }));\n}\n\nexport async function getAggregatedStock(): Promise<any[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const stores = await getStores();\n\n    const productMap = new Map(products.map(p => [p.id, p]));\n    const storeMap = new Map(stores.map(s => [s.id, s]));\n    \n    const aggregatedStock = new Map<string, any>();\n\n    for(const item of allStock) {\n        if (!productMap.has(item.productId)) continue;\n\n        if (!aggregatedStock.has(item.productId)) {\n            const product = productMap.get(item.productId)!;\n            aggregatedStock.set(item.productId, {\n                productId: item.productId,\n                itemName: product.itemName,\n                itemCode: product.itemCode,\n                totalQuantity: 0,\n                locations: [],\n            });\n        }\n\n        const aggItem = aggregatedStock.get(item.productId)!;\n        aggItem.totalQuantity += item.quantity;\n        aggItem.locations.push({\n            storeName: storeMap.get(item.storeId)?.name || 'Unknown Store',\n            quantity: item.quantity,\n        });\n    }\n\n    return Array.from(aggregatedStock.values());\n}\n\n\nexport async function getProductsForSelect(): Promise<{value: string, label: string}[]> {\n    const products = await readData<Product>(productsFilePath);\n    return products.map(p => ({ value: p.id, label: `${p.itemName} (${p.itemCode})`}));\n}\n\n\n// Transaction Actions\nconst transactionSchema = z.object({\n    storeId: z.string(),\n    productId: z.string(),\n    quantity: z.coerce.number().min(1, 'Quantity must be at least 1.'),\n    transactionType: z.enum(['IN', 'OUT']),\n    notes: z.string().optional(),\n    jobId: z.string().optional(),\n});\n\n\nexport async function recordStockTransaction(data: z.infer<typeof transactionSchema>) {\n    const validation = transactionSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: 'Invalid data format.' };\n    }\n\n    const { storeId, productId, quantity, transactionType, notes, jobId } = validation.data;\n    \n    // 1. Update Stock Level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === storeId && item.productId === productId);\n\n    if (transactionType === 'IN') {\n        if (stockItemIndex > -1) {\n            allStock[stockItemIndex].quantity += quantity;\n        } else {\n            allStock.push({\n                id: `STOCK-${Date.now()}`,\n                storeId,\n                productId,\n                quantity,\n            });\n        }\n    } else { // OUT\n        if (stockItemIndex === -1 || allStock[stockItemIndex].quantity < quantity) {\n            return { success: false, error: 'Insufficient stock for this transaction.' };\n        }\n        allStock[stockItemIndex].quantity -= quantity;\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // 2. Record Transaction\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === productId);\n    const store = (await getStores()).find(s => s.id === storeId);\n    \n    const newTransaction: StockTransaction = {\n        id: `TXN-${Date.now()}`,\n        date: new Date().toISOString(),\n        storeId,\n        storeName: store?.name || 'Unknown Store',\n        productId,\n        productName: product?.itemName || 'Unknown Item',\n        quantity,\n        type: transactionType,\n        notes,\n        jobId\n    };\n    allTransactions.push(newTransaction);\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    // 3. Financial Impact\n    const cost = product?.costPrice || 0;\n    const value = quantity * cost;\n    \n    // This is a simplified financial integration.\n    // A more robust system would create journal entries.\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140'); // Maintenance & Repairs\n\n    if (transactionType === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) + value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) - value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance = (allAccounts[expenseAccountIndex].balance || 0) + value;\n        }\n    }\n    \n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n\n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n\nexport async function getTransactionHistory(): Promise<StockTransaction[]> {\n    return await readData<StockTransaction>(stockTransactionsFilePath);\n}\n\nconst transferSchema = z.object({\n  fromStoreId: z.string().min(1, 'Source store is required'),\n  toStoreId: z.string().min(1, 'Destination store is required'),\n  productId: z.string().min(1, 'Product is required'),\n  quantity: z.coerce.number().min(1, 'Quantity must be at least 1'),\n  notes: z.string().optional(),\n}).refine(data => data.fromStoreId !== data.toStoreId, {\n    message: \"Source and destination stores cannot be the same.\",\n    path: ['toStoreId'],\n});\n\nexport async function transferStock(data: z.infer<typeof transferSchema>) {\n    const validation = transferSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: validation.error.errors[0].message };\n    }\n\n    const { fromStoreId, toStoreId, productId, quantity, notes } = validation.data;\n    \n    const allStock = await readData<StockItem>(stockFilePath);\n    const sourceStockIndex = allStock.findIndex(item => item.storeId === fromStoreId && item.productId === productId);\n    \n    // Check for sufficient stock\n    if (sourceStockIndex === -1 || allStock[sourceStockIndex].quantity < quantity) {\n        return { success: false, error: 'Insufficient stock in the source store.' };\n    }\n\n    // Decrement from source\n    allStock[sourceStockIndex].quantity -= quantity;\n\n    // Increment in destination\n    const destinationStockIndex = allStock.findIndex(item => item.storeId === toStoreId && item.productId === productId);\n    if (destinationStockIndex > -1) {\n        allStock[destinationStockIndex].quantity += quantity;\n    } else {\n        allStock.push({ id: `STOCK-${Date.now()}`, storeId: toStoreId, productId, quantity });\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // Record transactions\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const stores = await getStores();\n    const products = await readData<Product>(productsFilePath);\n    const fromStoreName = stores.find(s => s.id === fromStoreId)?.name || 'Unknown';\n    const toStoreName = stores.find(s => s.id === toStoreId)?.name || 'Unknown';\n    const productName = products.find(p => p.id === productId)?.itemName || 'Unknown';\n    const transferRef = `TRN-${Date.now()}`;\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-OUT`,\n        date: new Date().toISOString(),\n        storeId: fromStoreId,\n        storeName: fromStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'OUT',\n        notes: `Transfer to ${toStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-IN`,\n        date: new Date().toISOString(),\n        storeId: toStoreId,\n        storeName: toStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'IN',\n        notes: `Transfer from ${fromStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\nexport async function deleteStockTransaction(transactionId: string) {\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const transactionToDelete = allTransactions.find(t => t.id === transactionId);\n\n    if (!transactionToDelete) {\n        return { success: false, error: \"Transaction not found.\" };\n    }\n    \n    // Reverse stock level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === transactionToDelete.storeId && item.productId === transactionToDelete.productId);\n\n    if (stockItemIndex > -1) {\n        if (transactionToDelete.type === 'IN') {\n            allStock[stockItemIndex].quantity -= transactionToDelete.quantity;\n        } else { // OUT\n            allStock[stockItemIndex].quantity += transactionToDelete.quantity;\n        }\n        await writeData(stockFilePath, allStock);\n    }\n\n    // Reverse financial impact\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === transactionToDelete.productId);\n    const cost = product?.costPrice || 0;\n    const value = transactionToDelete.quantity * cost;\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140');\n\n    if (transactionToDelete.type === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance -= value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance += value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance -= value;\n        }\n    }\n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n    // Remove transaction log\n    const updatedTransactions = allTransactions.filter(t => t.id !== transactionId);\n    await writeData(stockTransactionsFilePath, updatedTransactions);\n    \n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IA+NsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 2468, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { storeSchema, stockItemSchema, type Store, type StockItem, type StockTransaction } from './schema';\nimport { type Product } from '@/app/products/schema';\n\nconst storesFilePath = path.join(process.cwd(), 'src/app/stores/stores-data.json');\nconst stockFilePath = path.join(process.cwd(), 'src/app/stores/stock-data.json');\nconst stockTransactionsFilePath = path.join(process.cwd(), 'src/app/stores/stock-transactions.json');\nconst productsFilePath = path.join(process.cwd(), 'src/app/products/products-data.json');\n\n\nasync function readData<T>(filePath: string, defaultValue: T[] = []): Promise<T[]> {\n    try {\n        await fs.access(filePath);\n        const data = await fs.readFile(filePath, 'utf-8');\n        return JSON.parse(data);\n    } catch (error) {\n        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n            await fs.writeFile(filePath, JSON.stringify(defaultValue, null, 2), 'utf-8');\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n\nasync function writeData(filePath: string, data: any) {\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n}\n\n\n// Store Actions\nexport async function getStores(): Promise<Store[]> {\n    return await readData<Store>(storesFilePath);\n}\n\nexport async function saveStore(data: Omit<Store, 'id'> & { id?: string }) {\n    const validation = storeSchema.omit({id: true}).safeParse(data);\n    if (!validation.success) return { success: false, error: 'Invalid data format.' };\n\n    const stores = await getStores();\n    if (data.id) { // Update\n        const index = stores.findIndex(s => s.id === data.id);\n        if (index === -1) return { success: false, error: 'Store not found.' };\n        stores[index] = { ...stores[index], ...validation.data };\n    } else { // Create\n        const newStore: Store = { ...validation.data, id: `STORE-${Date.now()}` };\n        stores.push(newStore);\n    }\n\n    await writeData(storesFilePath, stores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\nexport async function deleteStore(storeId: string) {\n    const stores = await getStores();\n    const updatedStores = stores.filter(s => s.id !== storeId);\n    if (stores.length === updatedStores.length) {\n        return { success: false, error: 'Store not found.' };\n    }\n    await writeData(storesFilePath, updatedStores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\n// Stock Actions\nexport async function getStockForStore(storeId: string): Promise<StockItem[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const productMap = new Map(products.map(p => [p.id, p]));\n\n    return allStock\n        .filter(item => item.storeId === storeId)\n        .map(item => ({\n            ...item,\n            itemName: productMap.get(item.productId)?.itemName || 'Unknown Item',\n            itemCode: productMap.get(item.productId)?.itemCode || 'Unknown',\n        }));\n}\n\nexport async function getAggregatedStock(): Promise<any[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const stores = await getStores();\n\n    const productMap = new Map(products.map(p => [p.id, p]));\n    const storeMap = new Map(stores.map(s => [s.id, s]));\n    \n    const aggregatedStock = new Map<string, any>();\n\n    for(const item of allStock) {\n        if (!productMap.has(item.productId)) continue;\n\n        if (!aggregatedStock.has(item.productId)) {\n            const product = productMap.get(item.productId)!;\n            aggregatedStock.set(item.productId, {\n                productId: item.productId,\n                itemName: product.itemName,\n                itemCode: product.itemCode,\n                totalQuantity: 0,\n                locations: [],\n            });\n        }\n\n        const aggItem = aggregatedStock.get(item.productId)!;\n        aggItem.totalQuantity += item.quantity;\n        aggItem.locations.push({\n            storeName: storeMap.get(item.storeId)?.name || 'Unknown Store',\n            quantity: item.quantity,\n        });\n    }\n\n    return Array.from(aggregatedStock.values());\n}\n\n\nexport async function getProductsForSelect(): Promise<{value: string, label: string}[]> {\n    const products = await readData<Product>(productsFilePath);\n    return products.map(p => ({ value: p.id, label: `${p.itemName} (${p.itemCode})`}));\n}\n\n\n// Transaction Actions\nconst transactionSchema = z.object({\n    storeId: z.string(),\n    productId: z.string(),\n    quantity: z.coerce.number().min(1, 'Quantity must be at least 1.'),\n    transactionType: z.enum(['IN', 'OUT']),\n    notes: z.string().optional(),\n    jobId: z.string().optional(),\n});\n\n\nexport async function recordStockTransaction(data: z.infer<typeof transactionSchema>) {\n    const validation = transactionSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: 'Invalid data format.' };\n    }\n\n    const { storeId, productId, quantity, transactionType, notes, jobId } = validation.data;\n    \n    // 1. Update Stock Level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === storeId && item.productId === productId);\n\n    if (transactionType === 'IN') {\n        if (stockItemIndex > -1) {\n            allStock[stockItemIndex].quantity += quantity;\n        } else {\n            allStock.push({\n                id: `STOCK-${Date.now()}`,\n                storeId,\n                productId,\n                quantity,\n            });\n        }\n    } else { // OUT\n        if (stockItemIndex === -1 || allStock[stockItemIndex].quantity < quantity) {\n            return { success: false, error: 'Insufficient stock for this transaction.' };\n        }\n        allStock[stockItemIndex].quantity -= quantity;\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // 2. Record Transaction\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === productId);\n    const store = (await getStores()).find(s => s.id === storeId);\n    \n    const newTransaction: StockTransaction = {\n        id: `TXN-${Date.now()}`,\n        date: new Date().toISOString(),\n        storeId,\n        storeName: store?.name || 'Unknown Store',\n        productId,\n        productName: product?.itemName || 'Unknown Item',\n        quantity,\n        type: transactionType,\n        notes,\n        jobId\n    };\n    allTransactions.push(newTransaction);\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    // 3. Financial Impact\n    const cost = product?.costPrice || 0;\n    const value = quantity * cost;\n    \n    // This is a simplified financial integration.\n    // A more robust system would create journal entries.\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140'); // Maintenance & Repairs\n\n    if (transactionType === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) + value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) - value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance = (allAccounts[expenseAccountIndex].balance || 0) + value;\n        }\n    }\n    \n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n\n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n\nexport async function getTransactionHistory(): Promise<StockTransaction[]> {\n    return await readData<StockTransaction>(stockTransactionsFilePath);\n}\n\nconst transferSchema = z.object({\n  fromStoreId: z.string().min(1, 'Source store is required'),\n  toStoreId: z.string().min(1, 'Destination store is required'),\n  productId: z.string().min(1, 'Product is required'),\n  quantity: z.coerce.number().min(1, 'Quantity must be at least 1'),\n  notes: z.string().optional(),\n}).refine(data => data.fromStoreId !== data.toStoreId, {\n    message: \"Source and destination stores cannot be the same.\",\n    path: ['toStoreId'],\n});\n\nexport async function transferStock(data: z.infer<typeof transferSchema>) {\n    const validation = transferSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: validation.error.errors[0].message };\n    }\n\n    const { fromStoreId, toStoreId, productId, quantity, notes } = validation.data;\n    \n    const allStock = await readData<StockItem>(stockFilePath);\n    const sourceStockIndex = allStock.findIndex(item => item.storeId === fromStoreId && item.productId === productId);\n    \n    // Check for sufficient stock\n    if (sourceStockIndex === -1 || allStock[sourceStockIndex].quantity < quantity) {\n        return { success: false, error: 'Insufficient stock in the source store.' };\n    }\n\n    // Decrement from source\n    allStock[sourceStockIndex].quantity -= quantity;\n\n    // Increment in destination\n    const destinationStockIndex = allStock.findIndex(item => item.storeId === toStoreId && item.productId === productId);\n    if (destinationStockIndex > -1) {\n        allStock[destinationStockIndex].quantity += quantity;\n    } else {\n        allStock.push({ id: `STOCK-${Date.now()}`, storeId: toStoreId, productId, quantity });\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // Record transactions\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const stores = await getStores();\n    const products = await readData<Product>(productsFilePath);\n    const fromStoreName = stores.find(s => s.id === fromStoreId)?.name || 'Unknown';\n    const toStoreName = stores.find(s => s.id === toStoreId)?.name || 'Unknown';\n    const productName = products.find(p => p.id === productId)?.itemName || 'Unknown';\n    const transferRef = `TRN-${Date.now()}`;\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-OUT`,\n        date: new Date().toISOString(),\n        storeId: fromStoreId,\n        storeName: fromStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'OUT',\n        notes: `Transfer to ${toStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-IN`,\n        date: new Date().toISOString(),\n        storeId: toStoreId,\n        storeName: toStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'IN',\n        notes: `Transfer from ${fromStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\nexport async function deleteStockTransaction(transactionId: string) {\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const transactionToDelete = allTransactions.find(t => t.id === transactionId);\n\n    if (!transactionToDelete) {\n        return { success: false, error: \"Transaction not found.\" };\n    }\n    \n    // Reverse stock level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === transactionToDelete.storeId && item.productId === transactionToDelete.productId);\n\n    if (stockItemIndex > -1) {\n        if (transactionToDelete.type === 'IN') {\n            allStock[stockItemIndex].quantity -= transactionToDelete.quantity;\n        } else { // OUT\n            allStock[stockItemIndex].quantity += transactionToDelete.quantity;\n        }\n        await writeData(stockFilePath, allStock);\n    }\n\n    // Reverse financial impact\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === transactionToDelete.productId);\n    const cost = product?.costPrice || 0;\n    const value = transactionToDelete.quantity * cost;\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140');\n\n    if (transactionToDelete.type === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance -= value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance += value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance -= value;\n        }\n    }\n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n    // Remove transaction log\n    const updatedTransactions = allTransactions.filter(t => t.id !== transactionId);\n    await writeData(stockTransactionsFilePath, updatedTransactions);\n    \n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IAmTsB,yBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 2483, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/scroll-area.tsx"],"sourcesContent":["\n\"use client\"\n\nimport * as React from \"react\"\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ScrollArea = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <ScrollAreaPrimitive.Root\n    ref={ref}\n    className={cn(\"relative overflow-hidden\", className)}\n    {...props}\n  >\n    <ScrollAreaPrimitive.Viewport className=\"h-full w-full rounded-[inherit]\">\n      {children}\n    </ScrollAreaPrimitive.Viewport>\n    <ScrollBar />\n    <ScrollBar orientation=\"horizontal\" />\n    <ScrollAreaPrimitive.Corner />\n  </ScrollAreaPrimitive.Root>\n))\nScrollArea.displayName = ScrollAreaPrimitive.Root.displayName\n\nconst ScrollBar = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>\n>(({ className, orientation = \"vertical\", ...props }, ref) => (\n  <ScrollAreaPrimitive.ScrollAreaScrollbar\n    ref={ref}\n    orientation={orientation}\n    className={cn(\n      \"flex touch-none select-none transition-colors\",\n      orientation === \"vertical\" &&\n        \"h-full w-2.5 border-l border-l-transparent p-[1px]\",\n      orientation === \"horizontal\" &&\n        \"h-2.5 flex-col border-t border-t-transparent p-[1px]\",\n      className\n    )}\n    {...props}\n  >\n    <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-border\" />\n  </ScrollAreaPrimitive.ScrollAreaScrollbar>\n))\nScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName\n\nexport { ScrollArea, ScrollBar }\n"],"names":[],"mappings":";;;;;;;AAGA;AACA;AAEA;AALA;;;;;AAOA,MAAM,2BAAa,2KAAgB,MAGjC,QAAoC;QAAnC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO;yBAClC,6LAAC,qLAAwB;QACvB,KAAK;QACL,WAAW,IAAA,4HAAE,EAAC,4BAA4B;QACzC,GAAG,KAAK;;0BAET,6LAAC,yLAA4B;gBAAC,WAAU;0BACrC;;;;;;0BAEH,6LAAC;;;;;0BACD,6LAAC;gBAAU,aAAY;;;;;;0BACvB,6LAAC,uLAA0B;;;;;;;;;;;;;AAG/B,WAAW,WAAW,GAAG,qLAAwB,CAAC,WAAW;AAE7D,MAAM,0BAAY,2KAAgB,CAGhC,QAAoD;QAAnD,EAAE,SAAS,EAAE,cAAc,UAAU,EAAE,GAAG,OAAO;yBAClD,6LAAC,oMAAuC;QACtC,KAAK;QACL,aAAa;QACb,WAAW,IAAA,4HAAE,EACX,iDACA,gBAAgB,cACd,sDACF,gBAAgB,gBACd,wDACF;QAED,GAAG,KAAK;kBAET,cAAA,6LAAC,gMAAmC;YAAC,WAAU;;;;;;;;;;;;MAjB7C;AAoBN,UAAU,WAAW,GAAG,oMAAuC,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 2573, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/transaction-history-dialog.tsx"],"sourcesContent":["\n'use client';\n\nimport { useState, useEffect, useRef } from 'react';\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n  DialogClose,\n} from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { useToast } from '@/hooks/use-toast';\nimport { Loader2, ArrowDown, ArrowUp, Printer, MoreHorizontal, Edit, Trash2 } from 'lucide-react';\nimport { type StockTransaction } from './schema';\nimport { getTransactionHistory, deleteStockTransaction } from './actions';\nimport { ScrollArea } from '@/components/ui/scroll-area';\nimport { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';\nimport { format } from 'date-fns';\nimport { cn } from '@/lib/utils';\nimport jsPDF from 'jspdf';\nimport 'jspdf-autotable';\nimport { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from '@/components/ui/alert-dialog';\nimport { type UserRole } from '@/app/admin/user-roles/schema';\nimport { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';\n\n\ninterface TransactionHistoryDialogProps {\n  isOpen: boolean;\n  setIsOpen: (open: boolean) => void;\n}\n\nexport function TransactionHistoryDialog({ isOpen, setIsOpen }: TransactionHistoryDialogProps) {\n  const [transactions, setTransactions] = useState<StockTransaction[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const printRef = useRef<HTMLDivElement>(null);\n  const [currentUserRole, setCurrentUserRole] = useState<UserRole['role'] | null>(null);\n  const [isDeleting, setIsDeleting] = useState(false);\n  const [selectedTxId, setSelectedTxId] = useState<string | null>(null);\n  const { toast } = useToast();\n\n  const fetchHistory = async () => {\n    setIsLoading(true);\n    const data = await getTransactionHistory();\n    setTransactions(data);\n    setIsLoading(false);\n  }\n\n  useEffect(() => {\n    const storedProfile = sessionStorage.getItem('userProfile');\n    if (storedProfile) {\n        setCurrentUserRole(JSON.parse(storedProfile).role);\n    }\n    if (isOpen) {\n        fetchHistory();\n    }\n  }, [isOpen]);\n  \n  const handleDelete = async () => {\n    if (!selectedTxId) return;\n    setIsDeleting(true);\n    const result = await deleteStockTransaction(selectedTxId);\n    if (result.success) {\n        toast({title: 'Success', description: 'Transaction has been deleted and financials reversed.'});\n        fetchHistory(); // Refresh list\n    } else {\n        toast({variant: 'destructive', title: 'Error', description: result.error});\n    }\n    setIsDeleting(false);\n    setSelectedTxId(null);\n  }\n\n  const handlePrint = () => {\n    const printContent = printRef.current?.innerHTML;\n    if (printContent) {\n        const printWindow = window.open('', '', 'height=800,width=800');\n        if (printWindow) {\n            printWindow.document.write('<html><head><title>Stock Transaction History</title>');\n            printWindow.document.write('<style>body { font-family: sans-serif; } table { width: 100%; border-collapse: collapse; } th, td { border: 1px solid #ddd; padding: 8px; } h1 { text-align: center; } .no-print { display: none; } </style>');\n            printWindow.document.write('</head><body>');\n            printWindow.document.write('<h1>Stock Transaction History</h1>');\n            printWindow.document.write(printContent.innerHTML);\n            printWindow.document.write('</body></html>');\n            printWindow.document.close();\n            printWindow.print();\n        }\n    }\n  };\n\n\n  return (\n    <Dialog open={isOpen} onOpenChange={setIsOpen}>\n       <AlertDialog open={!!selectedTxId} onOpenChange={(open) => !open && setSelectedTxId(null)}>\n            <AlertDialogContent>\n                <AlertDialogHeader>\n                <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>\n                <AlertDialogDescription>This will permanently delete the transaction and reverse its financial impact. This action cannot be undone.</AlertDialogDescription>\n                </AlertDialogHeader>\n                <AlertDialogFooter>\n                <AlertDialogCancel>Cancel</AlertDialogCancel>\n                <AlertDialogAction onClick={handleDelete} disabled={isDeleting}>\n                    {isDeleting ? 'Deleting...' : 'Delete'}\n                </AlertDialogAction>\n                </AlertDialogFooter>\n            </AlertDialogContent>\n        </AlertDialog>\n      <DialogContent className=\"sm:max-w-4xl\">\n            <DialogHeader>\n            <DialogTitle>Stock Transaction History</DialogTitle>\n            <DialogDescription>\n                A log of all inventory movements across all stores.\n            </DialogDescription>\n            </DialogHeader>\n             <div className=\"grid gap-4 py-4\">\n               <ScrollArea className=\"h-96 rounded-md border\" ref={printRef}>\n                 <Table>\n                    <TableHeader>\n                        <TableRow>\n                            <TableHead>Date</TableHead>\n                            <TableHead>Store</TableHead>\n                            <TableHead>Item</TableHead>\n                            <TableHead className=\"text-right\">Quantity</TableHead>\n                            <TableHead>Notes/Job</TableHead>\n                            {currentUserRole === 'Super Admin' && <TableHead className=\"text-right no-print\">Actions</TableHead>}\n                        </TableRow>\n                    </TableHeader>\n                    <TableBody>\n                        {isLoading ? (\n                            <TableRow>\n                                <TableCell colSpan={6} className=\"h-24 text-center\">\n                                    <Loader2 className=\"mx-auto h-6 w-6 animate-spin\"/>\n                                </TableCell>\n                            </TableRow>\n                        ) : transactions.length === 0 ? (\n                             <TableRow>\n                                <TableCell colSpan={6} className=\"h-24 text-center\">No transactions yet.</TableCell>\n                            </TableRow>\n                        ) : (\n                            transactions.slice().reverse().map(tx => (\n                                <TableRow key={tx.id}>\n                                    <TableCell>{format(new Date(tx.date), 'PP p')}</TableCell>\n                                    <TableCell>{tx.storeName}</TableCell>\n                                    <TableCell>{tx.productName}</TableCell>\n                                    <TableCell className={cn(\"text-right font-medium flex items-center justify-end gap-1\", tx.type === 'IN' ? 'text-green-600' : 'text-red-600')}>\n                                        {tx.type === 'IN' ? <ArrowDown className=\"h-4 w-4\"/> : <ArrowUp className=\"h-4 w-4\"/>}\n                                        {tx.quantity}\n                                    </TableCell>\n                                    <TableCell>{tx.jobId || tx.notes}</TableCell>\n                                     {currentUserRole === 'Super Admin' && (\n                                        <TableCell className=\"text-right no-print\">\n                                            <DropdownMenu>\n                                                <DropdownMenuTrigger asChild>\n                                                    <Button variant=\"ghost\" size=\"icon\"><MoreHorizontal className=\"h-4 w-4\"/></Button>\n                                                </DropdownMenuTrigger>\n                                                <DropdownMenuContent>\n                                                    <DropdownMenuItem disabled>\n                                                        <Edit className=\"mr-2 h-4 w-4\"/> Edit\n                                                    </DropdownMenuItem>\n                                                    <DropdownMenuItem className=\"text-destructive\" onSelect={() => setSelectedTxId(tx.id)}>\n                                                        <Trash2 className=\"mr-2 h-4 w-4\"/> Delete\n                                                    </DropdownMenuItem>\n                                                </DropdownMenuContent>\n                                            </DropdownMenu>\n                                        </TableCell>\n                                    )}\n                                </TableRow>\n                            ))\n                        )}\n                    </TableBody>\n                 </Table>\n               </ScrollArea>\n            </div>\n            <DialogFooter>\n                <Button type=\"button\" variant=\"outline\" onClick={handlePrint}>\n                    <Printer className=\"mr-2 h-4 w-4\" /> Print\n                </Button>\n                <DialogClose asChild>\n                    <Button type=\"button\" variant=\"outline\">Close</Button>\n                </DialogClose>\n            </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3102, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/stock-management.tsx"],"sourcesContent":["\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport { type Store, type StockItem } from './schema';\nimport { getStockForStore } from './actions';\nimport { DataTable } from './data-table';\nimport { columns } from './columns';\nimport { Button } from '@/components/ui/button';\nimport { ArrowDown, ArrowUp, History, Loader2, RotateCcw } from 'lucide-react';\nimport { StockInDialog } from './stock-in-dialog';\nimport { StockOutDialog } from './stock-out-dialog';\nimport { TransactionHistoryDialog } from './transaction-history-dialog';\n\nexport function StockManagement({ store }: { store: Store }) {\n    const [stock, setStock] = useState<StockItem[]>([]);\n    const [isLoading, setIsLoading] = useState(true);\n    const [isStockInOpen, setIsStockInOpen] = useState(false);\n    const [isStockOutOpen, setIsStockOutOpen] = useState(false);\n    const [isHistoryOpen, setIsHistoryOpen] = useState(false);\n\n    const refreshStock = async () => {\n        setIsLoading(true);\n        const stockData = await getStockForStore(store.id);\n        setStock(stockData);\n        setIsLoading(false);\n    }\n    \n    useEffect(() => {\n        refreshStock();\n    }, [store.id]);\n\n    return (\n        <div>\n             <div className=\"flex gap-2 mb-4\">\n                <Button size=\"sm\" onClick={() => setIsStockInOpen(true)}><ArrowDown className=\"mr-2 h-4 w-4\" /> Stock In</Button>\n                <Button size=\"sm\" variant=\"secondary\" onClick={() => setIsStockOutOpen(true)}><ArrowUp className=\"mr-2 h-4 w-4\"/> Stock Out</Button>\n                 <Button size=\"sm\" variant=\"outline\" onClick={() => setIsHistoryOpen(true)}><History className=\"mr-2 h-4 w-4\" /> History</Button>\n                 <Button size=\"icon\" variant=\"ghost\" onClick={refreshStock}><RotateCcw className=\"h-4 w-4\"/></Button>\n            </div>\n            <StockInDialog isOpen={isStockInOpen} setIsOpen={setIsStockInOpen} store={store} onSuccess={refreshStock} />\n            <StockOutDialog isOpen={isStockOutOpen} setIsOpen={setIsStockOutOpen} store={store} onSuccess={refreshStock} />\n            <TransactionHistoryDialog isOpen={isHistoryOpen} setIsOpen={setIsHistoryOpen} />\n            {isLoading ? (\n                <div className=\"flex justify-center items-center h-40\"><Loader2 className=\"h-6 w-6 animate-spin\"/></div>\n            ) : (\n                <DataTable columns={columns} data={stock} storeName={store.name} />\n            )}\n        </div>\n    )\n}\n"],"names":[],"mappings":";;;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;AAXA;;;;;;;;;;AAaO,SAAS,gBAAgB,KAA2B;QAA3B,EAAE,KAAK,EAAoB,GAA3B;;IAC5B,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAc,EAAE;IAClD,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAC;IAC3C,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,yKAAQ,EAAC;IACnD,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,yKAAQ,EAAC;IACrD,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,yKAAQ,EAAC;IAEnD,MAAM,eAAe;QACjB,aAAa;QACb,MAAM,YAAY,MAAM,IAAA,mLAAgB,EAAC,MAAM,EAAE;QACjD,SAAS;QACT,aAAa;IACjB;IAEA,IAAA,0KAAS;qCAAC;YACN;QACJ;oCAAG;QAAC,MAAM,EAAE;KAAC;IAEb,qBACI,6LAAC;;0BACI,6LAAC;gBAAI,WAAU;;kCACZ,6LAAC,+IAAM;wBAAC,MAAK;wBAAK,SAAS,IAAM,iBAAiB;;0CAAO,6LAAC,gOAAS;gCAAC,WAAU;;;;;;4BAAiB;;;;;;;kCAC/F,6LAAC,+IAAM;wBAAC,MAAK;wBAAK,SAAQ;wBAAY,SAAS,IAAM,kBAAkB;;0CAAO,6LAAC,0NAAO;gCAAC,WAAU;;;;;;4BAAgB;;;;;;;kCAChH,6LAAC,+IAAM;wBAAC,MAAK;wBAAK,SAAQ;wBAAU,SAAS,IAAM,iBAAiB;;0CAAO,6LAAC,sNAAO;gCAAC,WAAU;;;;;;4BAAiB;;;;;;;kCAC/G,6LAAC,+IAAM;wBAAC,MAAK;wBAAO,SAAQ;wBAAQ,SAAS;kCAAc,cAAA,6LAAC,gOAAS;4BAAC,WAAU;;;;;;;;;;;;;;;;;0BAErF,6LAAC,kKAAa;gBAAC,QAAQ;gBAAe,WAAW;gBAAkB,OAAO;gBAAO,WAAW;;;;;;0BAC5F,6LAAC,oKAAc;gBAAC,QAAQ;gBAAgB,WAAW;gBAAmB,OAAO;gBAAO,WAAW;;;;;;0BAC/F,6LAAC,wLAAwB;gBAAC,QAAQ;gBAAe,WAAW;;;;;;YAC3D,0BACG,6LAAC;gBAAI,WAAU;0BAAwC,cAAA,6LAAC,+NAAO;oBAAC,WAAU;;;;;;;;;;qCAE1E,6LAAC,sJAAS;gBAAC,SAAS,8IAAO;gBAAE,MAAM;gBAAO,WAAW,MAAM,IAAI;;;;;;;;;;;;AAI/E;GApCgB;KAAA","debugId":null}},
    {"offset": {"line": 3304, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { storeSchema, stockItemSchema, type Store, type StockItem, type StockTransaction } from './schema';\nimport { type Product } from '@/app/products/schema';\n\nconst storesFilePath = path.join(process.cwd(), 'src/app/stores/stores-data.json');\nconst stockFilePath = path.join(process.cwd(), 'src/app/stores/stock-data.json');\nconst stockTransactionsFilePath = path.join(process.cwd(), 'src/app/stores/stock-transactions.json');\nconst productsFilePath = path.join(process.cwd(), 'src/app/products/products-data.json');\n\n\nasync function readData<T>(filePath: string, defaultValue: T[] = []): Promise<T[]> {\n    try {\n        await fs.access(filePath);\n        const data = await fs.readFile(filePath, 'utf-8');\n        return JSON.parse(data);\n    } catch (error) {\n        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n            await fs.writeFile(filePath, JSON.stringify(defaultValue, null, 2), 'utf-8');\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n\nasync function writeData(filePath: string, data: any) {\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n}\n\n\n// Store Actions\nexport async function getStores(): Promise<Store[]> {\n    return await readData<Store>(storesFilePath);\n}\n\nexport async function saveStore(data: Omit<Store, 'id'> & { id?: string }) {\n    const validation = storeSchema.omit({id: true}).safeParse(data);\n    if (!validation.success) return { success: false, error: 'Invalid data format.' };\n\n    const stores = await getStores();\n    if (data.id) { // Update\n        const index = stores.findIndex(s => s.id === data.id);\n        if (index === -1) return { success: false, error: 'Store not found.' };\n        stores[index] = { ...stores[index], ...validation.data };\n    } else { // Create\n        const newStore: Store = { ...validation.data, id: `STORE-${Date.now()}` };\n        stores.push(newStore);\n    }\n\n    await writeData(storesFilePath, stores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\nexport async function deleteStore(storeId: string) {\n    const stores = await getStores();\n    const updatedStores = stores.filter(s => s.id !== storeId);\n    if (stores.length === updatedStores.length) {\n        return { success: false, error: 'Store not found.' };\n    }\n    await writeData(storesFilePath, updatedStores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\n// Stock Actions\nexport async function getStockForStore(storeId: string): Promise<StockItem[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const productMap = new Map(products.map(p => [p.id, p]));\n\n    return allStock\n        .filter(item => item.storeId === storeId)\n        .map(item => ({\n            ...item,\n            itemName: productMap.get(item.productId)?.itemName || 'Unknown Item',\n            itemCode: productMap.get(item.productId)?.itemCode || 'Unknown',\n        }));\n}\n\nexport async function getAggregatedStock(): Promise<any[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const stores = await getStores();\n\n    const productMap = new Map(products.map(p => [p.id, p]));\n    const storeMap = new Map(stores.map(s => [s.id, s]));\n    \n    const aggregatedStock = new Map<string, any>();\n\n    for(const item of allStock) {\n        if (!productMap.has(item.productId)) continue;\n\n        if (!aggregatedStock.has(item.productId)) {\n            const product = productMap.get(item.productId)!;\n            aggregatedStock.set(item.productId, {\n                productId: item.productId,\n                itemName: product.itemName,\n                itemCode: product.itemCode,\n                totalQuantity: 0,\n                locations: [],\n            });\n        }\n\n        const aggItem = aggregatedStock.get(item.productId)!;\n        aggItem.totalQuantity += item.quantity;\n        aggItem.locations.push({\n            storeName: storeMap.get(item.storeId)?.name || 'Unknown Store',\n            quantity: item.quantity,\n        });\n    }\n\n    return Array.from(aggregatedStock.values());\n}\n\n\nexport async function getProductsForSelect(): Promise<{value: string, label: string}[]> {\n    const products = await readData<Product>(productsFilePath);\n    return products.map(p => ({ value: p.id, label: `${p.itemName} (${p.itemCode})`}));\n}\n\n\n// Transaction Actions\nconst transactionSchema = z.object({\n    storeId: z.string(),\n    productId: z.string(),\n    quantity: z.coerce.number().min(1, 'Quantity must be at least 1.'),\n    transactionType: z.enum(['IN', 'OUT']),\n    notes: z.string().optional(),\n    jobId: z.string().optional(),\n});\n\n\nexport async function recordStockTransaction(data: z.infer<typeof transactionSchema>) {\n    const validation = transactionSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: 'Invalid data format.' };\n    }\n\n    const { storeId, productId, quantity, transactionType, notes, jobId } = validation.data;\n    \n    // 1. Update Stock Level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === storeId && item.productId === productId);\n\n    if (transactionType === 'IN') {\n        if (stockItemIndex > -1) {\n            allStock[stockItemIndex].quantity += quantity;\n        } else {\n            allStock.push({\n                id: `STOCK-${Date.now()}`,\n                storeId,\n                productId,\n                quantity,\n            });\n        }\n    } else { // OUT\n        if (stockItemIndex === -1 || allStock[stockItemIndex].quantity < quantity) {\n            return { success: false, error: 'Insufficient stock for this transaction.' };\n        }\n        allStock[stockItemIndex].quantity -= quantity;\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // 2. Record Transaction\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === productId);\n    const store = (await getStores()).find(s => s.id === storeId);\n    \n    const newTransaction: StockTransaction = {\n        id: `TXN-${Date.now()}`,\n        date: new Date().toISOString(),\n        storeId,\n        storeName: store?.name || 'Unknown Store',\n        productId,\n        productName: product?.itemName || 'Unknown Item',\n        quantity,\n        type: transactionType,\n        notes,\n        jobId\n    };\n    allTransactions.push(newTransaction);\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    // 3. Financial Impact\n    const cost = product?.costPrice || 0;\n    const value = quantity * cost;\n    \n    // This is a simplified financial integration.\n    // A more robust system would create journal entries.\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140'); // Maintenance & Repairs\n\n    if (transactionType === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) + value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) - value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance = (allAccounts[expenseAccountIndex].balance || 0) + value;\n        }\n    }\n    \n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n\n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n\nexport async function getTransactionHistory(): Promise<StockTransaction[]> {\n    return await readData<StockTransaction>(stockTransactionsFilePath);\n}\n\nconst transferSchema = z.object({\n  fromStoreId: z.string().min(1, 'Source store is required'),\n  toStoreId: z.string().min(1, 'Destination store is required'),\n  productId: z.string().min(1, 'Product is required'),\n  quantity: z.coerce.number().min(1, 'Quantity must be at least 1'),\n  notes: z.string().optional(),\n}).refine(data => data.fromStoreId !== data.toStoreId, {\n    message: \"Source and destination stores cannot be the same.\",\n    path: ['toStoreId'],\n});\n\nexport async function transferStock(data: z.infer<typeof transferSchema>) {\n    const validation = transferSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: validation.error.errors[0].message };\n    }\n\n    const { fromStoreId, toStoreId, productId, quantity, notes } = validation.data;\n    \n    const allStock = await readData<StockItem>(stockFilePath);\n    const sourceStockIndex = allStock.findIndex(item => item.storeId === fromStoreId && item.productId === productId);\n    \n    // Check for sufficient stock\n    if (sourceStockIndex === -1 || allStock[sourceStockIndex].quantity < quantity) {\n        return { success: false, error: 'Insufficient stock in the source store.' };\n    }\n\n    // Decrement from source\n    allStock[sourceStockIndex].quantity -= quantity;\n\n    // Increment in destination\n    const destinationStockIndex = allStock.findIndex(item => item.storeId === toStoreId && item.productId === productId);\n    if (destinationStockIndex > -1) {\n        allStock[destinationStockIndex].quantity += quantity;\n    } else {\n        allStock.push({ id: `STOCK-${Date.now()}`, storeId: toStoreId, productId, quantity });\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // Record transactions\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const stores = await getStores();\n    const products = await readData<Product>(productsFilePath);\n    const fromStoreName = stores.find(s => s.id === fromStoreId)?.name || 'Unknown';\n    const toStoreName = stores.find(s => s.id === toStoreId)?.name || 'Unknown';\n    const productName = products.find(p => p.id === productId)?.itemName || 'Unknown';\n    const transferRef = `TRN-${Date.now()}`;\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-OUT`,\n        date: new Date().toISOString(),\n        storeId: fromStoreId,\n        storeName: fromStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'OUT',\n        notes: `Transfer to ${toStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-IN`,\n        date: new Date().toISOString(),\n        storeId: toStoreId,\n        storeName: toStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'IN',\n        notes: `Transfer from ${fromStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\nexport async function deleteStockTransaction(transactionId: string) {\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const transactionToDelete = allTransactions.find(t => t.id === transactionId);\n\n    if (!transactionToDelete) {\n        return { success: false, error: \"Transaction not found.\" };\n    }\n    \n    // Reverse stock level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === transactionToDelete.storeId && item.productId === transactionToDelete.productId);\n\n    if (stockItemIndex > -1) {\n        if (transactionToDelete.type === 'IN') {\n            allStock[stockItemIndex].quantity -= transactionToDelete.quantity;\n        } else { // OUT\n            allStock[stockItemIndex].quantity += transactionToDelete.quantity;\n        }\n        await writeData(stockFilePath, allStock);\n    }\n\n    // Reverse financial impact\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === transactionToDelete.productId);\n    const cost = product?.costPrice || 0;\n    const value = transactionToDelete.quantity * cost;\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140');\n\n    if (transactionToDelete.type === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance -= value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance += value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance -= value;\n        }\n    }\n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n    // Remove transaction log\n    const updatedTransactions = allTransactions.filter(t => t.id !== transactionId);\n    await writeData(stockTransactionsFilePath, updatedTransactions);\n    \n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IA2DsB,cAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 3319, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\nimport { storeSchema, stockItemSchema, type Store, type StockItem, type StockTransaction } from './schema';\nimport { type Product } from '@/app/products/schema';\n\nconst storesFilePath = path.join(process.cwd(), 'src/app/stores/stores-data.json');\nconst stockFilePath = path.join(process.cwd(), 'src/app/stores/stock-data.json');\nconst stockTransactionsFilePath = path.join(process.cwd(), 'src/app/stores/stock-transactions.json');\nconst productsFilePath = path.join(process.cwd(), 'src/app/products/products-data.json');\n\n\nasync function readData<T>(filePath: string, defaultValue: T[] = []): Promise<T[]> {\n    try {\n        await fs.access(filePath);\n        const data = await fs.readFile(filePath, 'utf-8');\n        return JSON.parse(data);\n    } catch (error) {\n        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n            await fs.writeFile(filePath, JSON.stringify(defaultValue, null, 2), 'utf-8');\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n\nasync function writeData(filePath: string, data: any) {\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n}\n\n\n// Store Actions\nexport async function getStores(): Promise<Store[]> {\n    return await readData<Store>(storesFilePath);\n}\n\nexport async function saveStore(data: Omit<Store, 'id'> & { id?: string }) {\n    const validation = storeSchema.omit({id: true}).safeParse(data);\n    if (!validation.success) return { success: false, error: 'Invalid data format.' };\n\n    const stores = await getStores();\n    if (data.id) { // Update\n        const index = stores.findIndex(s => s.id === data.id);\n        if (index === -1) return { success: false, error: 'Store not found.' };\n        stores[index] = { ...stores[index], ...validation.data };\n    } else { // Create\n        const newStore: Store = { ...validation.data, id: `STORE-${Date.now()}` };\n        stores.push(newStore);\n    }\n\n    await writeData(storesFilePath, stores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\nexport async function deleteStore(storeId: string) {\n    const stores = await getStores();\n    const updatedStores = stores.filter(s => s.id !== storeId);\n    if (stores.length === updatedStores.length) {\n        return { success: false, error: 'Store not found.' };\n    }\n    await writeData(storesFilePath, updatedStores);\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\n// Stock Actions\nexport async function getStockForStore(storeId: string): Promise<StockItem[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const productMap = new Map(products.map(p => [p.id, p]));\n\n    return allStock\n        .filter(item => item.storeId === storeId)\n        .map(item => ({\n            ...item,\n            itemName: productMap.get(item.productId)?.itemName || 'Unknown Item',\n            itemCode: productMap.get(item.productId)?.itemCode || 'Unknown',\n        }));\n}\n\nexport async function getAggregatedStock(): Promise<any[]> {\n    const allStock = await readData<StockItem>(stockFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const stores = await getStores();\n\n    const productMap = new Map(products.map(p => [p.id, p]));\n    const storeMap = new Map(stores.map(s => [s.id, s]));\n    \n    const aggregatedStock = new Map<string, any>();\n\n    for(const item of allStock) {\n        if (!productMap.has(item.productId)) continue;\n\n        if (!aggregatedStock.has(item.productId)) {\n            const product = productMap.get(item.productId)!;\n            aggregatedStock.set(item.productId, {\n                productId: item.productId,\n                itemName: product.itemName,\n                itemCode: product.itemCode,\n                totalQuantity: 0,\n                locations: [],\n            });\n        }\n\n        const aggItem = aggregatedStock.get(item.productId)!;\n        aggItem.totalQuantity += item.quantity;\n        aggItem.locations.push({\n            storeName: storeMap.get(item.storeId)?.name || 'Unknown Store',\n            quantity: item.quantity,\n        });\n    }\n\n    return Array.from(aggregatedStock.values());\n}\n\n\nexport async function getProductsForSelect(): Promise<{value: string, label: string}[]> {\n    const products = await readData<Product>(productsFilePath);\n    return products.map(p => ({ value: p.id, label: `${p.itemName} (${p.itemCode})`}));\n}\n\n\n// Transaction Actions\nconst transactionSchema = z.object({\n    storeId: z.string(),\n    productId: z.string(),\n    quantity: z.coerce.number().min(1, 'Quantity must be at least 1.'),\n    transactionType: z.enum(['IN', 'OUT']),\n    notes: z.string().optional(),\n    jobId: z.string().optional(),\n});\n\n\nexport async function recordStockTransaction(data: z.infer<typeof transactionSchema>) {\n    const validation = transactionSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: 'Invalid data format.' };\n    }\n\n    const { storeId, productId, quantity, transactionType, notes, jobId } = validation.data;\n    \n    // 1. Update Stock Level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === storeId && item.productId === productId);\n\n    if (transactionType === 'IN') {\n        if (stockItemIndex > -1) {\n            allStock[stockItemIndex].quantity += quantity;\n        } else {\n            allStock.push({\n                id: `STOCK-${Date.now()}`,\n                storeId,\n                productId,\n                quantity,\n            });\n        }\n    } else { // OUT\n        if (stockItemIndex === -1 || allStock[stockItemIndex].quantity < quantity) {\n            return { success: false, error: 'Insufficient stock for this transaction.' };\n        }\n        allStock[stockItemIndex].quantity -= quantity;\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // 2. Record Transaction\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === productId);\n    const store = (await getStores()).find(s => s.id === storeId);\n    \n    const newTransaction: StockTransaction = {\n        id: `TXN-${Date.now()}`,\n        date: new Date().toISOString(),\n        storeId,\n        storeName: store?.name || 'Unknown Store',\n        productId,\n        productName: product?.itemName || 'Unknown Item',\n        quantity,\n        type: transactionType,\n        notes,\n        jobId\n    };\n    allTransactions.push(newTransaction);\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    // 3. Financial Impact\n    const cost = product?.costPrice || 0;\n    const value = quantity * cost;\n    \n    // This is a simplified financial integration.\n    // A more robust system would create journal entries.\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140'); // Maintenance & Repairs\n\n    if (transactionType === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) + value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance = (allAccounts[inventoryAccountIndex].balance || 0) - value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance = (allAccounts[expenseAccountIndex].balance || 0) + value;\n        }\n    }\n    \n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n\n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n\nexport async function getTransactionHistory(): Promise<StockTransaction[]> {\n    return await readData<StockTransaction>(stockTransactionsFilePath);\n}\n\nconst transferSchema = z.object({\n  fromStoreId: z.string().min(1, 'Source store is required'),\n  toStoreId: z.string().min(1, 'Destination store is required'),\n  productId: z.string().min(1, 'Product is required'),\n  quantity: z.coerce.number().min(1, 'Quantity must be at least 1'),\n  notes: z.string().optional(),\n}).refine(data => data.fromStoreId !== data.toStoreId, {\n    message: \"Source and destination stores cannot be the same.\",\n    path: ['toStoreId'],\n});\n\nexport async function transferStock(data: z.infer<typeof transferSchema>) {\n    const validation = transferSchema.safeParse(data);\n    if (!validation.success) {\n        return { success: false, error: validation.error.errors[0].message };\n    }\n\n    const { fromStoreId, toStoreId, productId, quantity, notes } = validation.data;\n    \n    const allStock = await readData<StockItem>(stockFilePath);\n    const sourceStockIndex = allStock.findIndex(item => item.storeId === fromStoreId && item.productId === productId);\n    \n    // Check for sufficient stock\n    if (sourceStockIndex === -1 || allStock[sourceStockIndex].quantity < quantity) {\n        return { success: false, error: 'Insufficient stock in the source store.' };\n    }\n\n    // Decrement from source\n    allStock[sourceStockIndex].quantity -= quantity;\n\n    // Increment in destination\n    const destinationStockIndex = allStock.findIndex(item => item.storeId === toStoreId && item.productId === productId);\n    if (destinationStockIndex > -1) {\n        allStock[destinationStockIndex].quantity += quantity;\n    } else {\n        allStock.push({ id: `STOCK-${Date.now()}`, storeId: toStoreId, productId, quantity });\n    }\n\n    await writeData(stockFilePath, allStock);\n    \n    // Record transactions\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const stores = await getStores();\n    const products = await readData<Product>(productsFilePath);\n    const fromStoreName = stores.find(s => s.id === fromStoreId)?.name || 'Unknown';\n    const toStoreName = stores.find(s => s.id === toStoreId)?.name || 'Unknown';\n    const productName = products.find(p => p.id === productId)?.itemName || 'Unknown';\n    const transferRef = `TRN-${Date.now()}`;\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-OUT`,\n        date: new Date().toISOString(),\n        storeId: fromStoreId,\n        storeName: fromStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'OUT',\n        notes: `Transfer to ${toStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    allTransactions.push({\n        id: `TXN-${Date.now()}-IN`,\n        date: new Date().toISOString(),\n        storeId: toStoreId,\n        storeName: toStoreName,\n        productId,\n        productName,\n        quantity,\n        type: 'IN',\n        notes: `Transfer from ${fromStoreName}. Ref: ${transferRef}. ${notes || ''}`,\n    });\n\n    await writeData(stockTransactionsFilePath, allTransactions);\n\n    revalidatePath('/stores');\n    return { success: true };\n}\n\n\nexport async function deleteStockTransaction(transactionId: string) {\n    const allTransactions = await readData<StockTransaction>(stockTransactionsFilePath);\n    const transactionToDelete = allTransactions.find(t => t.id === transactionId);\n\n    if (!transactionToDelete) {\n        return { success: false, error: \"Transaction not found.\" };\n    }\n    \n    // Reverse stock level\n    const allStock = await readData<StockItem>(stockFilePath);\n    const stockItemIndex = allStock.findIndex(item => item.storeId === transactionToDelete.storeId && item.productId === transactionToDelete.productId);\n\n    if (stockItemIndex > -1) {\n        if (transactionToDelete.type === 'IN') {\n            allStock[stockItemIndex].quantity -= transactionToDelete.quantity;\n        } else { // OUT\n            allStock[stockItemIndex].quantity += transactionToDelete.quantity;\n        }\n        await writeData(stockFilePath, allStock);\n    }\n\n    // Reverse financial impact\n    const products = await readData<Product>(productsFilePath);\n    const product = products.find(p => p.id === transactionToDelete.productId);\n    const cost = product?.costPrice || 0;\n    const value = transactionToDelete.quantity * cost;\n    const allAccounts = await readData<any>(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'));\n    const inventoryAccountIndex = allAccounts.findIndex(a => a.code === '1140');\n    const expenseAccountIndex = allAccounts.findIndex(a => a.code === '5140');\n\n    if (transactionToDelete.type === 'IN') {\n        if (inventoryAccountIndex > -1) {\n            allAccounts[inventoryAccountIndex].balance -= value;\n        }\n    } else { // OUT\n        if (inventoryAccountIndex > -1) {\n             allAccounts[inventoryAccountIndex].balance += value;\n        }\n        if (expenseAccountIndex > -1) {\n             allAccounts[expenseAccountIndex].balance -= value;\n        }\n    }\n    await writeData(path.join(process.cwd(), 'src/app/finance/chart-of-accounts/accounts.json'), allAccounts);\n\n    // Remove transaction log\n    const updatedTransactions = allTransactions.filter(t => t.id !== transactionId);\n    await writeData(stockTransactionsFilePath, updatedTransactions);\n    \n    revalidatePath('/stores');\n    revalidatePath('/finance/chart-of-accounts');\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IA8OsB,gBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 3334, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/stock-transfer-dialog.tsx"],"sourcesContent":["\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n  DialogClose,\n} from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { useToast } from '@/hooks/use-toast';\nimport { Loader2 } from 'lucide-react';\nimport { useForm, Controller } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { getProductsForSelect, transferStock } from './actions';\nimport { type Store } from './schema';\nimport { Combobox } from '@/components/ui/combobox';\nimport { Textarea } from '@/components/ui/textarea';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\n\nconst formSchema = z.object({\n  fromStoreId: z.string().min(1, 'Source store is required'),\n  toStoreId: z.string().min(1, 'Destination store is required'),\n  productId: z.string().min(1, 'Please select a product.'),\n  quantity: z.coerce.number().min(1, 'Quantity must be at least 1.'),\n  notes: z.string().optional(),\n}).refine(data => data.fromStoreId !== data.toStoreId, {\n    message: \"Source and destination stores cannot be the same.\",\n    path: ['toStoreId'],\n});\n\ntype FormData = z.infer<typeof formSchema>;\n\ninterface StockTransferDialogProps {\n  isOpen: boolean;\n  setIsOpen: (open: boolean) => void;\n  stores: Store[];\n  onSuccess: () => void;\n}\n\nexport function StockTransferDialog({ isOpen, setIsOpen, stores, onSuccess }: StockTransferDialogProps) {\n  const [isSaving, setIsSaving] = useState(false);\n  const [products, setProducts] = useState<{value: string, label: string}[]>([]);\n  const { toast } = useToast();\n\n  const {\n    register,\n    handleSubmit,\n    control,\n    reset,\n    formState: { errors },\n  } = useForm<FormData>({\n    resolver: zodResolver(formSchema),\n    defaultValues: { quantity: 1 }\n  });\n\n  useEffect(() => {\n    if (isOpen) {\n        getProductsForSelect().then(setProducts);\n        reset({ quantity: 1, productId: '', notes: '', fromStoreId: '', toStoreId: '' });\n    }\n  }, [isOpen, reset]);\n\n  const onSubmit = async (data: FormData) => {\n    setIsSaving(true);\n    const result = await transferStock(data);\n\n    if (result.success) {\n      toast({\n        title: 'Stock Transferred',\n        description: 'Inventory has been updated successfully.',\n      });\n      onSuccess();\n      setIsOpen(false);\n    } else {\n      toast({\n        variant: 'destructive',\n        title: 'Error',\n        description: result.error,\n      });\n    }\n    setIsSaving(false);\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={setIsOpen}>\n      <DialogContent>\n        <form onSubmit={handleSubmit(onSubmit)}>\n            <DialogHeader>\n            <DialogTitle>Transfer Stock Between Stores</DialogTitle>\n            <DialogDescription>\n                Move items from one inventory location to another.\n            </DialogDescription>\n            </DialogHeader>\n            <div className=\"grid gap-4 py-4\">\n                <div className=\"grid grid-cols-2 gap-4\">\n                    <div className=\"space-y-2\">\n                        <Label>From Store</Label>\n                         <Controller\n                            name=\"fromStoreId\"\n                            control={control}\n                            render={({ field }) => (\n                                <Select onValueChange={field.onChange} value={field.value}>\n                                    <SelectTrigger><SelectValue placeholder=\"Select Source\"/></SelectTrigger>\n                                    <SelectContent>\n                                        {stores.map(store => <SelectItem key={store.id} value={store.id}>{store.name}</SelectItem>)}\n                                    </SelectContent>\n                                </Select>\n                            )}\n                        />\n                         {errors.fromStoreId && <p className=\"text-destructive text-xs mt-1\">{errors.fromStoreId.message}</p>}\n                    </div>\n                     <div className=\"space-y-2\">\n                        <Label>To Store</Label>\n                         <Controller\n                            name=\"toStoreId\"\n                            control={control}\n                            render={({ field }) => (\n                                <Select onValueChange={field.onChange} value={field.value}>\n                                    <SelectTrigger><SelectValue placeholder=\"Select Destination\"/></SelectTrigger>\n                                    <SelectContent>\n                                        {stores.map(store => <SelectItem key={store.id} value={store.id}>{store.name}</SelectItem>)}\n                                    </SelectContent>\n                                </Select>\n                            )}\n                        />\n                         {errors.toStoreId && <p className=\"text-destructive text-xs mt-1\">{errors.toStoreId.message}</p>}\n                    </div>\n                </div>\n                <div className=\"space-y-2\">\n                    <Label htmlFor=\"productId\">Product / Service</Label>\n                     <Controller\n                        name=\"productId\"\n                        control={control}\n                        render={({ field }) => (\n                           <Combobox\n                                options={products}\n                                value={field.value || ''}\n                                onSelect={field.onChange}\n                                placeholder=\"Select an item\"\n                           />\n                        )}\n                    />\n                    {errors.productId && <p className=\"text-destructive text-xs mt-1\">{errors.productId.message}</p>}\n                </div>\n                 <div className=\"space-y-2\">\n                    <Label htmlFor=\"quantity\">Quantity</Label>\n                    <Input id=\"quantity\" type=\"number\" {...register('quantity')} />\n                    {errors.quantity && <p className=\"text-destructive text-xs mt-1\">{errors.quantity.message}</p>}\n                </div>\n                 <div className=\"space-y-2\">\n                    <Label htmlFor=\"notes\">Notes / Reference</Label>\n                    <Textarea id=\"notes\" {...register('notes')} placeholder=\"e.g., Transfer for Project X\" />\n                </div>\n            </div>\n            <DialogFooter>\n                <DialogClose asChild>\n                    <Button type=\"button\" variant=\"outline\">Cancel</Button>\n                </DialogClose>\n                <Button type=\"submit\" disabled={isSaving}>\n                    {isSaving && <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />}\n                    Confirm Transfer\n                </Button>\n            </DialogFooter>\n        </form>\n      </DialogContent>\n    </Dialog>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3803, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/stores/stores-client.tsx"],"sourcesContent":["\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport { AddStoreDialog } from './add-store-dialog';\nimport { type Store } from './schema';\nimport { getStores } from './actions';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';\nimport { Building, MapPin, MoreVertical, Pencil, Trash2, ArrowRightLeft } from 'lucide-react';\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from '@/components/ui/dropdown-menu';\nimport {\n    AlertDialog,\n    AlertDialogAction,\n    AlertDialogCancel,\n    AlertDialogContent,\n    AlertDialogDescription,\n    AlertDialogFooter,\n    AlertDialogHeader,\n    AlertDialogTitle,\n} from '@/components/ui/alert-dialog';\nimport { Button } from '@/components/ui/button';\nimport { StockManagement } from './stock-management';\nimport { deleteStore } from './actions';\nimport { useToast } from '@/hooks/use-toast';\nimport { StockTransferDialog } from './stock-transfer-dialog';\n\nconst StoreCard = ({ store, onEdit, onDelete }: { store: Store, onEdit: (store: Store) => void, onDelete: (storeId: string) => void }) => {\n    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);\n\n    return (\n        <>\n            <AlertDialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>\n                <AlertDialogContent>\n                    <AlertDialogHeader>\n                        <AlertDialogTitle>Are you sure?</AlertDialogTitle>\n                        <AlertDialogDescription>This will permanently delete the store \"{store.name}\". This action cannot be undone.</AlertDialogDescription>\n                    </AlertDialogHeader>\n                    <AlertDialogFooter>\n                        <AlertDialogCancel>Cancel</AlertDialogCancel>\n                        <AlertDialogAction onClick={() => onDelete(store.id)} className=\"bg-destructive hover:bg-destructive/90\">\n                           Delete\n                        </AlertDialogAction>\n                    </AlertDialogFooter>\n                </AlertDialogContent>\n            </AlertDialog>\n            <Card>\n                <CardHeader className=\"flex flex-row items-start justify-between\">\n                    <div>\n                        <CardTitle>{store.name}</CardTitle>\n                        <CardDescription className=\"flex items-center gap-2 pt-2\">\n                            <MapPin className=\"h-4 w-4\" /> {store.location || 'No location specified'}\n                        </CardDescription>\n                    </div>\n                    <DropdownMenu>\n                        <DropdownMenuTrigger asChild>\n                            <Button variant=\"ghost\" size=\"icon\"><MoreVertical className=\"h-4 w-4\"/></Button>\n                        </DropdownMenuTrigger>\n                        <DropdownMenuContent>\n                            <DropdownMenuItem onSelect={() => onEdit(store)}><Pencil className=\"mr-2 h-4 w-4\" />Edit</DropdownMenuItem>\n                            <DropdownMenuItem onSelect={() => setIsDeleteDialogOpen(true)} className=\"text-destructive\"><Trash2 className=\"mr-2 h-4 w-4\" />Delete</DropdownMenuItem>\n                        </DropdownMenuContent>\n                    </DropdownMenu>\n                </CardHeader>\n                <CardContent>\n                    <StockManagement store={store} />\n                </CardContent>\n            </Card>\n        </>\n    );\n}\n\n\nexport function StoresClient({ initialStores }: { initialStores: Store[] }) {\n  const [stores, setStores] = useState(initialStores);\n  const [isDialogOpen, setIsDialogOpen] = useState(false);\n  const [isTransferDialogOpen, setIsTransferDialogOpen] = useState(false);\n  const [selectedStore, setSelectedStore] = useState<Store | undefined>(undefined);\n  const { toast } = useToast();\n  \n  useEffect(() => {\n    setStores(initialStores);\n  }, [initialStores]);\n\n  const refreshStores = async () => {\n    const updatedStores = await getStores();\n    setStores(updatedStores);\n  };\n  \n  const handleEdit = (store: Store) => {\n    setSelectedStore(store);\n    setIsDialogOpen(true);\n  }\n  \n  const handleDelete = async (storeId: string) => {\n    const result = await deleteStore(storeId);\n    if(result.success) {\n        toast({ title: \"Store Deleted\", description: \"The store location has been removed.\" });\n        refreshStores();\n    } else {\n        toast({ variant: 'destructive', title: \"Error\", description: result.error });\n    }\n  }\n\n  return (\n     <div className=\"container mx-auto py-10\">\n        <AddStoreDialog\n            isOpen={isDialogOpen}\n            setIsOpen={setIsDialogOpen}\n            store={selectedStore}\n            onSuccess={() => {\n                refreshStores();\n                setSelectedStore(undefined);\n            }}\n        />\n        <StockTransferDialog\n            isOpen={isTransferDialogOpen}\n            setIsOpen={setIsTransferDialogOpen}\n            stores={stores}\n            onSuccess={refreshStores}\n        />\n\n        <div className=\"flex justify-between items-center mb-6\">\n            <div>\n                <h1 className=\"text-3xl font-bold font-headline\">Vaults & Stores</h1>\n                <p className=\"text-muted-foreground\">\n                    Manage your inventory across all locations.\n                </p>\n            </div>\n            <div className=\"flex items-center gap-2\">\n                 <Button variant=\"outline\" onClick={() => setIsTransferDialogOpen(true)}>\n                    <ArrowRightLeft className=\"mr-2 h-4 w-4\" /> Stock Transfer\n                </Button>\n                <Button onClick={() => { setSelectedStore(undefined); setIsDialogOpen(true); }}>\n                    Add New Store\n                </Button>\n            </div>\n        </div>\n        \n        <div className=\"mb-8\">\n            \n        </div>\n\n        {stores.length === 0 ? (\n            <div className=\"text-center py-20 border-2 border-dashed rounded-lg\">\n                <Building className=\"mx-auto h-12 w-12 text-muted-foreground\" />\n                <h3 className=\"mt-4 text-lg font-semibold\">No Stores Found</h3>\n                <p className=\"mt-2 text-sm text-muted-foreground\">Get started by adding your first store or vault location.</p>\n            </div>\n        ) : (\n             <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n                {stores.map(store => (\n                    <StoreCard key={store.id} store={store} onEdit={handleEdit} onDelete={handleDelete} />\n                ))}\n            </div>\n        )}\n    </div>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}