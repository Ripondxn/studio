
import { NextResponse } from 'next/server';
import { promises as fs } from 'fs';
import path from 'path';
import { format, startOfMonth, endOfMonth, isWithinInterval, parseISO } from 'date-fns';
import { type Tenant } from '@/app/tenancy/tenants/schema';
import { type Invoice } from '@/app/tenancy/customer/invoice/schema';
import { saveInvoice } from '@/app/tenancy/customer/invoice/actions';
import { getWorkflowSettings } from '@/app/admin/workflow-settings/actions';

const tenantsFilePath = path.join(process.cwd(), 'src/app/tenancy/tenants/tenants-data.json');
const invoicesFilePath = path.join(process.cwd(), 'src/app/tenancy/customer/invoice/invoices-data.json');

async function readData<T>(filePath: string): Promise<T[]> {
    try {
        const data = await fs.readFile(filePath, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
            return [];
        }
        throw error;
    }
}

export async function generateInvoices() {
  try {
    const workflowSettings = await getWorkflowSettings();
    if (!workflowSettings.automaticInvoiceGenerationEnabled) {
      return { success: true, message: 'Automatic invoice generation is disabled. No invoices were created.' };
    }
    
    const tenants = await readData<{tenantData: Tenant}>(tenantsFilePath);
    const existingInvoices = await readData<Invoice>(invoicesFilePath);

    const activeSubscriptions = tenants.filter(t => t.tenantData.isSubscriptionActive && t.tenantData.subscriptionStatus && t.tenantData.subscriptionAmount > 0);
    
    const now = new Date();
    const currentMonthKey = format(now, 'yyyy-MM');
    let invoicesCreatedCount = 0;

    for (const tenant of activeSubscriptions) {
        const tenantData = tenant.tenantData;
        const hasInvoiceForCurrentMonth = existingInvoices.some(inv => 
            inv.customerCode === tenantData.code &&
            format(parseISO(inv.invoiceDate), 'yyyy-MM') === currentMonthKey
        );
        
        if (!hasInvoiceForCurrentMonth) {
            const subscriptionAmount = tenantData.subscriptionAmount || 0;
            const newInvoiceData: Omit<Invoice, 'id' | 'amountPaid'> = {
                invoiceNo: '', // Will be generated by saveInvoice
                customerCode: tenantData.code,
                customerName: tenantData.name,
                property: tenantData.property || '',
                unitCode: tenantData.unitCode || '',
                roomCode: tenantData.roomCode || '',
                invoiceDate: format(now, 'yyyy-MM-dd'),
                dueDate: format(endOfMonth(now), 'yyyy-MM-dd'),
                items: [{ 
                    id: `item-${Date.now()}`, 
                    description: `${tenantData.subscriptionStatus} Subscription`, 
                    quantity: 1, 
                    unitPrice: subscriptionAmount, 
                    total: subscriptionAmount 
                }],
                subTotal: subscriptionAmount,
                tax: 0,
                taxType: 'exclusive',
                taxRate: 0,
                total: subscriptionAmount,
                notes: `Automatically generated subscription invoice for ${format(now, 'MMMM yyyy')}.`,
                status: 'Sent', // Assume invoices are sent immediately
            };

            await saveInvoice({ ...newInvoiceData, isAutoInvoiceNo: true }, 'Cron Job');
            invoicesCreatedCount++;
        }
    }
    
    return { success: true, message: `Cron job completed. ${invoicesCreatedCount} new invoices created.` };

  } catch (error) {
    console.error('Cron job for invoice generation failed:', error);
    throw new Error('Failed to generate invoices.');
  }
}


export async function GET(request: Request) {
    try {
        const result = await generateInvoices();
        return NextResponse.json(result);
    } catch(e: any) {
        return NextResponse.json({ success: false, error: e.message }, { status: 500 });
    }
}
