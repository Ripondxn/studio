

import { NextResponse } from 'next/server';
import { promises as fs } from 'fs';
import path from 'path';
import { format, startOfMonth, endOfMonth, isWithinInterval, parseISO, addMonths, getMonth, getYear, getDate } from 'date-fns';
import { type Tenant } from '@/app/tenancy/tenants/schema';
import { type Invoice } from '@/app/tenancy/customer/invoice/schema';
import { saveSubscriptionInvoice } from '@/app/tenancy/tenants/invoice/actions';
import { getWorkflowSettings } from '@/app/admin/workflow-settings/actions';

const tenantsFilePath = path.join(process.cwd(), 'src/app/tenancy/tenants/tenants-data.json');
const invoicesFilePath = path.join(process.cwd(), 'src/app/tenancy/tenants/invoice/subscription-invoices-data.json');

async function readData<T>(filePath: string): Promise<T[]> {
    try {
        const data = await fs.readFile(filePath, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
            return [];
        }
        throw error;
    }
}

export async function generateInvoices(forceRun = false) {
  try {
    const workflowSettings = await getWorkflowSettings();
    const today = new Date();

    if (!forceRun) {
        if (!workflowSettings.automaticInvoiceGenerationEnabled) {
          return { success: true, message: 'Automatic invoice generation is disabled. No invoices were created.' };
        }
        if (getDate(today) !== workflowSettings.invoiceGenerationDay) {
            return { success: true, message: `Skipping invoice generation. Today is not day ${workflowSettings.invoiceGenerationDay}.`};
        }
    }
    
    const tenants = await readData<{tenantData: Tenant}>(tenantsFilePath);
    const existingInvoices = await readData<Invoice>(invoicesFilePath);

    const activeSubscriptions = tenants.filter(t => t.tenantData.isSubscriptionActive && t.tenantData.subscriptionAmount > 0);
    
    const createdFor: string[] = [];

    for (const tenant of activeSubscriptions) {
        for (let i = 0; i < workflowSettings.monthsToGenerate; i++) {
            const targetMonthDate = addMonths(today, i);
            const targetMonthKey = format(targetMonthDate, 'yyyy-MM');

            const hasInvoiceForTargetMonth = existingInvoices.some(inv => 
                inv.customerCode === tenant.tenantData.code &&
                format(parseISO(inv.invoiceDate), 'yyyy-MM') === targetMonthKey
            );
            
            if (!hasInvoiceForTargetMonth) {
                const tenantData = tenant.tenantData;
                const subscriptionAmount = tenantData.subscriptionAmount || 0;
                
                const newInvoiceData: Omit<Invoice, 'id' | 'amountPaid'> = {
                    invoiceNo: '', // Will be generated by saveInvoice
                    customerCode: tenantData.code,
                    customerName: tenantData.name,
                    property: tenantData.property || '',
                    unitCode: tenantData.unitCode || '',
                    roomCode: tenantData.roomCode || '',
                    invoiceDate: format(targetMonthDate, 'yyyy-MM-dd'),
                    dueDate: format(endOfMonth(targetMonthDate), 'yyyy-MM-dd'),
                    items: [{ 
                        id: `item-${Date.now()}`, 
                        description: `${tenantData.subscriptionStatus} Subscription for ${format(targetMonthDate, 'MMMM yyyy')}`, 
                        quantity: 1, 
                        unitPrice: subscriptionAmount, 
                        total: subscriptionAmount 
                    }],
                    subTotal: subscriptionAmount,
                    tax: 0,
                    taxType: 'exclusive',
                    taxRate: 0,
                    total: subscriptionAmount,
                    notes: `Automatically generated subscription invoice for ${format(targetMonthDate, 'MMMM yyyy')}.`,
                    status: 'Sent', // Assume invoices are sent immediately
                };

                await saveSubscriptionInvoice({ ...newInvoiceData, isAutoInvoiceNo: true }, 'Cron Job');
                createdFor.push(`${tenantData.name} (for ${format(targetMonthDate, 'MMM yyyy')})`);
            }
        }
    }
    
    const message = createdFor.length > 0 
        ? `Created ${createdFor.length} new invoices for: ${createdFor.join(', ')}.`
        : 'No new invoices needed at this time.';
        
    return { success: true, message };

  } catch (error) {
    console.error('Cron job for invoice generation failed:', error);
    throw new Error('Failed to generate invoices.');
  }
}


export async function GET(request: Request) {
    try {
        const result = await generateInvoices();
        return NextResponse.json(result);
    } catch(e: any) {
        return NextResponse.json({ success: false, error: e.message }, { status: 500 });
    }
}
